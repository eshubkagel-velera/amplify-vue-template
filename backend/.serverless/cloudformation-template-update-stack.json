{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "The AWS CloudFormation template for this Serverless application",
  "Resources": {
    "EmailDomainValidationFunction": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "FunctionName": "email-domain-validation-dev",
        "Runtime": "nodejs18.x",
        "Handler": "index.handler",
        "Code": {
          "ZipFile": "exports.handler = async (event) => {\n  const email = event.request.userAttributes.email;\n  \n  // Input validation\n  if (!email || typeof email !== 'string') {\n    throw new Error('Invalid email format');\n  }\n  \n  var emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    throw new Error('Invalid email format');\n  }\n  \n  if (!email.endsWith('@velera.com')) {\n    throw new Error('Only @velera.com email addresses are allowed');\n  }\n  \n  console.log('Email validation passed for domain: ' + email.split('@')[1]);\n  return event;\n};\n"
        },
        "Role": {
          "Fn::GetAtt": [
            "LambdaExecutionRole",
            "Arn"
          ]
        }
      }
    },
    "PostConfirmationFunction": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "FunctionName": "post-confirmation-dev",
        "Runtime": "nodejs18.x",
        "Handler": "index.handler",
        "Code": {
          "ZipFile": "const { CognitoIdentityProviderClient, AdminAddUserToGroupCommand, ListUsersInGroupCommand } = require('@aws-sdk/client-cognito-identity-provider');\nconst { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');\n\nconst cognito = new CognitoIdentityProviderClient({ region: 'us-east-2' });\nconst ses = new SESClient({ region: 'us-east-2' });\n\nexports.handler = async (event) => {\n  const { userPoolId, userName } = event;\n  const userAttributes = event.request.userAttributes;\n  const region = process.env.AWS_REGION;\n  \n  // Input validation\n  if (!userAttributes.email || !userAttributes.email.includes('@')) {\n    console.error('Invalid email format');\n    return event;\n  }\n  \n  try {\n    // Add user to ReadOnly group by default\n    await cognito.send(new AdminAddUserToGroupCommand({\n      GroupName: 'readonly',\n      UserPoolId: userPoolId,\n      Username: userName\n    }));\n    \n    console.log('User ' + userName + ' added to readonly group');\n    \n    // Send notification to admins about new user\n    const adminUsers = await cognito.send(new ListUsersInGroupCommand({\n      GroupName: 'admin',\n      UserPoolId: userPoolId\n    }));\n    \n    const adminEmails = adminUsers.Users.map(user => \n      user.Attributes.find(attr => attr.Name === 'email')?.Value\n    ).filter(email => email && email.includes('@'));\n    \n    console.log('Admin emails found:', JSON.stringify(adminEmails));\n    \n    if (adminEmails.length > 0) {\n      const emailParams = {\n        Source: 'eshubkagel@velera.com',\n        Destination: { ToAddresses: adminEmails },\n        Message: {\n          Subject: { Data: 'New User Registration: ' + userAttributes.email.split('@')[0] + '@*** (' + (userAttributes.name || 'Unknown') + ')' },\n          Body: {\n            Text: {\n              Data: 'New user has registered and been added to readonly group.\\n\\nUser Details:\\n- Email: ' + userAttributes.email + '\\n- Username: ' + userName + '\\n- ' + (userAttributes.name || 'Requested Access: Unknown') + '\\n\\nTo add user to requested group:\\nhttps://us-east-2.console.aws.amazon.com/cognito/v2/idp/user-pools/' + userPoolId + '/user-management/groups/details/' + (userAttributes.name ? userAttributes.name.replace('Requested: ', '').toLowerCase() : 'developer') + '/add-user?region=' + region\n            }\n          }\n        }\n      };\n      \n      console.log('Sending email TO:', JSON.stringify(adminEmails));\n      const result = await ses.send(new SendEmailCommand(emailParams));\n      console.log('SES Response:', JSON.stringify(result));\n      console.log('Notification sent to ' + adminEmails.length + ' admins');\n    }\n  } catch (error) {\n    console.error('Error in post-confirmation:', error.message);\n    console.error('Full error:', JSON.stringify(error));\n  }\n  \n  return event;\n};\n"
        },
        "Role": {
          "Fn::GetAtt": [
            "PostConfirmationLambdaRole",
            "Arn"
          ]
        }
      }
    },
    "PostConfirmationLambdaRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "CognitoGroupManagement",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "cognito-idp:AdminAddUserToGroup",
                    "cognito-idp:ListUsersInGroup"
                  ],
                  "Resource": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
                },
                {
                  "Effect": "Allow",
                  "Action": [
                    "ses:SendEmail"
                  ],
                  "Resource": [
                    "arn:aws:ses:us-east-2:*:identity/eshubkagel@velera.com"
                  ]
                }
              ]
            }
          }
        ]
      }
    },
    "PostConfirmationLambdaPermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "PostConfirmationFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "cognito-idp.amazonaws.com",
        "SourceArn": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
      }
    },
    "LambdaExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        ]
      }
    },
    "CognitoLambdaPermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "EmailDomainValidationFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "cognito-idp.amazonaws.com",
        "SourceArn": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
      }
    },
    "AppSyncLoggingRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "appsync.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "Policies": [
          {
            "PolicyName": "CloudWatchLogsAccess",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents"
                  ],
                  "Resource": "*"
                }
              ]
            }
          }
        ]
      }
    },
    "RDSServiceRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "appsync.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "Policies": [
          {
            "PolicyName": "RDSDataAccess",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "rds-data:*"
                  ],
                  "Resource": [
                    "arn:aws:rds:us-east-2:*:cluster:hazel-mapping"
                  ]
                },
                {
                  "Effect": "Allow",
                  "Action": [
                    "secretsmanager:GetSecretValue",
                    "kms:Decrypt",
                    "kms:DescribeKey"
                  ],
                  "Resource": [
                    "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-a11d98c5-d647-45a2-9978-f81be7aa3d60-iDsvX3",
                    "arn:aws:kms:us-east-2:*:key/*"
                  ]
                },
                {
                  "Effect": "Allow",
                  "Action": [
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents"
                  ],
                  "Resource": [
                    "arn:aws:logs:us-east-2:*:log-group:/aws/appsync/*"
                  ]
                }
              ]
            }
          }
        ]
      }
    },
    "GraphQlApi": {
      "Type": "AWS::AppSync::GraphQLApi",
      "Properties": {
        "Name": "vue-appsync-api-dev",
        "AuthenticationType": "AMAZON_COGNITO_USER_POOLS",
        "AdditionalAuthenticationProviders": [
          {
            "AuthenticationType": "API_KEY"
          }
        ],
        "UserPoolConfig": {
          "AwsRegion": "us-east-2",
          "UserPoolId": "us-east-2_iAtP0Uzh5",
          "DefaultAction": "ALLOW"
        },
        "XrayEnabled": false
      }
    },
    "GraphQlApiKeyDefault": {
      "Type": "AWS::AppSync::ApiKey",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "Description": "Auto-generated api key",
        "Expires": 1792011600
      }
    },
    "GraphQlSchema": {
      "Type": "AWS::AppSync::GraphQLSchema",
      "Properties": {
        "Definition": "schema {\n  query: Query\n  mutation: Mutation\n  subscription: Subscription\n}\n\ntype CONFIG_PARAM {\n  CONFIG_PARAM_ID: Int\n  CONFIG_NAME: String!\n  CONFIG_VALUE: String!\n  DESCRIPTION: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ntype FILTER_CRITERIA {\n  FILTER_CRITERIA_ID: Int\n  ORIGIN_PRODUCT_ID: Int!\n  STEP_TYPE_ID: Int!\n  CRITERIA: String!\n  SEQUENCE_NBR: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ntype LOAN_APP {\n  LOAN_APP_ID: Int\n  ORIGIN_LOAN_APP_ID: String!\n  ORIGIN_PRODUCT_ID: Int!\n  PROCESS_FLAG: String!\n  EXEC_ID: String\n  CREATED_DATE: String!\n  CHANGED_DATE: String\n}\n\ntype LOAN_APP_EXECS {\n  LOAN_APP_EXEC_ID: Int\n  LOAN_APP_ID: Int!\n  AWS_EXEC_ID: String!\n  CREATED_DATE: String!\n}\n\ntype LOAN_APP_STEP_STATUS {\n  LOAN_APP_STEP_STATUS_ID: Int\n  LOAN_APP_ID: Int!\n  LOAN_APP_EXEC_ID: Int\n  STEP_TYPE_ID: Int!\n  COMPLETE_FLAG: String!\n  SEQUENCE_NBR: Int!\n  IDX_JSON_PATH: String\n  RESPONSE_TEXT: String\n  OUTPUT_JSON: String\n  CREATED_DATE: String\n}\n\ntype NEW_MEMBER_TOKEN {\n  NEW_MEMBER_TOKEN_ID: Int\n  MEMBER_NBR: String\n  CARD_NBR: String\n  PERSON_NBR: String\n  LOAN_APP_ID: Int!\n  FIRST_NAME: String\n  LAST_NAME: String\n  DOB: String\n  TAX_ID: String\n  EMAIL_ADDRESS_TEXT: String\n  ZIP_CODE: String\n  HOME_PHONE_NBR: String\n  MOBILE_PHONE_NBR: String\n  TOKEN_VALUE: String\n  TOKEN_USED_FLAG: String!\n  CREATED_DATE: String!\n  CHANGED_DATE: String\n}\n\ntype ORIGIN_PRODUCT {\n  ORIGIN_PRODUCT_ID: Int\n  VENDOR_NAME: String!\n  PRODUCT_ID: String!\n  PSCU_CLIENT_ID: Int!\n  PRODUCT_DESC: String!\n  PARTNER_CODE: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype REDIRECT_URL {\n  REDIRECT_URL_ID: Int\n  ORIGIN_PRODUCT_ID: Int!\n  URL_TYPE_CODE: String!\n  URL: String!\n  RESPONSE_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE {\n  SERVICE_ID: Int\n  SERVICE_PROVIDER_ID: Int!\n  URI: String!\n  SECRET_NAME: String\n  REQUEST_TYPE: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE_DOMAIN {\n  SERVICE_DOMAIN_ID: Int\n  DOMAIN_URL: String\n  SERVICE_PROVIDER_ID: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ntype SERVICE_EXPR_MAPPING {\n  SERVICE_EXPR_MAPPING_ID: Int\n  SERVICE_PARAM_MAPPING_ID: Int!\n  SOURCE_EXPR: String\n  TARGET_EXPR: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE_PARAM {\n  SERVICE_PARAM_ID: Int\n  SERVICE_ID: Int!\n  PARAM_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE_PARAM_MAPPING {\n  SERVICE_PARAM_MAPPING_ID: Int\n  ORIGIN_PRODUCT_ID: Int!\n  SYSTEM_NBR: String\n  PRIN_NBR: String\n  AGENT_NBR: String\n  SOURCE_SERVICE_PARAM_ID: Int!\n  TARGET_SERVICE_PARAM_ID: Int!\n  PLASTIC_TYPE_ID: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE_PROVIDER {\n  SERVICE_PROVIDER_ID: Int\n  SERVICE_PROVIDER_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SORT_CRITERIA {\n  SORT_CRITERIA_ID: Int\n  ORIGIN_PRODUCT_ID: Int!\n  STEP_TYPE_ID: Int!\n  JSON_PATH: String!\n  SORT_ORDER: String!\n  SORT_PRIORITY: Int!\n  SEQUENCE_NBR: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ntype STEP_SERVICE_MAPPING {\n  STEP_SERVICE_MAPPING_ID: Int\n  STEP_TYPE_ID: Int!\n  SERVICE_ID: Int!\n  SEQUENCE_NBR: Int\n}\n\ntype STEP_TYPE {\n  STEP_TYPE_ID: Int\n  STEP_TYPE_NAME: String!\n  STEP_TYPE_DESC: String\n  RESOURCE_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype STEP_TYPE_PARAM_MAP {\n  STEP_TYPE_PARAM_MAP_ID: Int\n  STEP_TYPE_ID: Int\n  SERVICE_PARAM_MAPPING_ID: Int!\n  CREATED_BY_USER_ID: String\n  CREATED_DATE: String\n}\n\ninput CreateCONFIG_PARAMInput {\n  CONFIG_NAME: String!\n  CONFIG_VALUE: String!\n  DESCRIPTION: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput UpdateCONFIG_PARAMInput {\n  CONFIG_PARAM_ID: Int!\n  CONFIG_NAME: String\n  CONFIG_VALUE: String\n  DESCRIPTION: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteCONFIG_PARAMInput {\n  CONFIG_PARAM_ID: Int!\n}\n\ninput CreateFILTER_CRITERIAInput {\n  ORIGIN_PRODUCT_ID: Int!\n  STEP_TYPE_ID: Int!\n  CRITERIA: String!\n  SEQUENCE_NBR: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput UpdateFILTER_CRITERIAInput {\n  FILTER_CRITERIA_ID: Int!\n  ORIGIN_PRODUCT_ID: Int\n  STEP_TYPE_ID: Int\n  CRITERIA: String\n  SEQUENCE_NBR: Int\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteFILTER_CRITERIAInput {\n  FILTER_CRITERIA_ID: Int!\n}\n\ninput CreateLOAN_APPInput {\n  ORIGIN_LOAN_APP_ID: String!\n  ORIGIN_PRODUCT_ID: Int!\n  PROCESS_FLAG: String!\n  EXEC_ID: String\n  CREATED_DATE: String!\n  CHANGED_DATE: String\n}\n\ninput UpdateLOAN_APPInput {\n  LOAN_APP_ID: Int!\n  ORIGIN_LOAN_APP_ID: String\n  ORIGIN_PRODUCT_ID: Int\n  PROCESS_FLAG: String\n  EXEC_ID: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteLOAN_APPInput {\n  LOAN_APP_ID: Int!\n}\n\ninput CreateLOAN_APP_EXECSInput {\n  LOAN_APP_ID: Int!\n  AWS_EXEC_ID: String!\n  CREATED_DATE: String!\n}\n\ninput UpdateLOAN_APP_EXECSInput {\n  LOAN_APP_EXEC_ID: Int!\n  LOAN_APP_ID: Int\n  AWS_EXEC_ID: String\n  CREATED_DATE: String\n}\n\ninput DeleteLOAN_APP_EXECSInput {\n  LOAN_APP_EXEC_ID: Int!\n}\n\ninput CreateLOAN_APP_STEP_STATUSInput {\n  LOAN_APP_ID: Int!\n  LOAN_APP_EXEC_ID: Int\n  STEP_TYPE_ID: Int!\n  COMPLETE_FLAG: String!\n  SEQUENCE_NBR: Int!\n  IDX_JSON_PATH: String\n  RESPONSE_TEXT: String\n  OUTPUT_JSON: String\n  CREATED_DATE: String\n}\n\ninput UpdateLOAN_APP_STEP_STATUSInput {\n  LOAN_APP_STEP_STATUS_ID: Int!\n  LOAN_APP_ID: Int\n  LOAN_APP_EXEC_ID: Int\n  STEP_TYPE_ID: Int\n  COMPLETE_FLAG: String\n  SEQUENCE_NBR: Int\n  IDX_JSON_PATH: String\n  RESPONSE_TEXT: String\n  OUTPUT_JSON: String\n  CREATED_DATE: String\n}\n\ninput DeleteLOAN_APP_STEP_STATUSInput {\n  LOAN_APP_STEP_STATUS_ID: Int!\n}\n\ninput CreateNEW_MEMBER_TOKENInput {\n  MEMBER_NBR: String\n  CARD_NBR: String\n  PERSON_NBR: String\n  LOAN_APP_ID: Int!\n  FIRST_NAME: String\n  LAST_NAME: String\n  DOB: String\n  TAX_ID: String\n  EMAIL_ADDRESS_TEXT: String\n  ZIP_CODE: String\n  HOME_PHONE_NBR: String\n  MOBILE_PHONE_NBR: String\n  TOKEN_VALUE: String\n  TOKEN_USED_FLAG: String!\n  CREATED_DATE: String!\n  CHANGED_DATE: String\n}\n\ninput UpdateNEW_MEMBER_TOKENInput {\n  NEW_MEMBER_TOKEN_ID: Int!\n  MEMBER_NBR: String\n  CARD_NBR: String\n  PERSON_NBR: String\n  LOAN_APP_ID: Int\n  FIRST_NAME: String\n  LAST_NAME: String\n  DOB: String\n  TAX_ID: String\n  EMAIL_ADDRESS_TEXT: String\n  ZIP_CODE: String\n  HOME_PHONE_NBR: String\n  MOBILE_PHONE_NBR: String\n  TOKEN_VALUE: String\n  TOKEN_USED_FLAG: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteNEW_MEMBER_TOKENInput {\n  NEW_MEMBER_TOKEN_ID: Int!\n}\n\ninput CreateORIGIN_PRODUCTInput {\n  VENDOR_NAME: String!\n  PRODUCT_ID: String!\n  PSCU_CLIENT_ID: Int!\n  PRODUCT_DESC: String!\n  PARTNER_CODE: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateORIGIN_PRODUCTInput {\n  ORIGIN_PRODUCT_ID: Int!\n  VENDOR_NAME: String\n  PRODUCT_ID: String\n  PSCU_CLIENT_ID: Int\n  PRODUCT_DESC: String\n  PARTNER_CODE: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteORIGIN_PRODUCTInput {\n  ORIGIN_PRODUCT_ID: Int!\n}\n\ninput CreateREDIRECT_URLInput {\n  ORIGIN_PRODUCT_ID: Int!\n  URL_TYPE_CODE: String!\n  URL: String!\n  RESPONSE_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateREDIRECT_URLInput {\n  REDIRECT_URL_ID: Int!\n  ORIGIN_PRODUCT_ID: Int\n  URL_TYPE_CODE: String\n  URL: String\n  RESPONSE_TEXT: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteREDIRECT_URLInput {\n  REDIRECT_URL_ID: Int!\n}\n\ninput CreateSERVICEInput {\n  SERVICE_PROVIDER_ID: Int!\n  URI: String!\n  SECRET_NAME: String\n  REQUEST_TYPE: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICEInput {\n  SERVICE_ID: Int!\n  SERVICE_PROVIDER_ID: Int\n  URI: String\n  SECRET_NAME: String\n  REQUEST_TYPE: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICEInput {\n  SERVICE_ID: Int!\n}\n\ninput CreateSERVICE_DOMAINInput {\n  DOMAIN_URL: String\n  SERVICE_PROVIDER_ID: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_DOMAINInput {\n  SERVICE_DOMAIN_ID: Int!\n  DOMAIN_URL: String\n  SERVICE_PROVIDER_ID: Int\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_DOMAINInput {\n  SERVICE_DOMAIN_ID: Int!\n}\n\ninput CreateSERVICE_EXPR_MAPPINGInput {\n  SERVICE_PARAM_MAPPING_ID: Int!\n  SOURCE_EXPR: String\n  TARGET_EXPR: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_EXPR_MAPPINGInput {\n  SERVICE_EXPR_MAPPING_ID: Int!\n  SERVICE_PARAM_MAPPING_ID: Int\n  SOURCE_EXPR: String\n  TARGET_EXPR: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_EXPR_MAPPINGInput {\n  SERVICE_EXPR_MAPPING_ID: Int!\n}\n\ninput CreateSERVICE_PARAMInput {\n  SERVICE_ID: Int!\n  PARAM_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_PARAMInput {\n  SERVICE_PARAM_ID: Int!\n  SERVICE_ID: Int\n  PARAM_NAME: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_PARAMInput {\n  SERVICE_PARAM_ID: Int!\n}\n\ninput CreateSERVICE_PARAM_MAPPINGInput {\n  ORIGIN_PRODUCT_ID: Int!\n  SYSTEM_NBR: String\n  PRIN_NBR: String\n  AGENT_NBR: String\n  SOURCE_SERVICE_PARAM_ID: Int!\n  TARGET_SERVICE_PARAM_ID: Int!\n  PLASTIC_TYPE_ID: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_PARAM_MAPPINGInput {\n  SERVICE_PARAM_MAPPING_ID: Int!\n  ORIGIN_PRODUCT_ID: Int\n  SYSTEM_NBR: String\n  PRIN_NBR: String\n  AGENT_NBR: String\n  SOURCE_SERVICE_PARAM_ID: Int\n  TARGET_SERVICE_PARAM_ID: Int\n  PLASTIC_TYPE_ID: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_PARAM_MAPPINGInput {\n  SERVICE_PARAM_MAPPING_ID: Int!\n}\n\ninput CreateSERVICE_PROVIDERInput {\n  SERVICE_PROVIDER_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_PROVIDERInput {\n  SERVICE_PROVIDER_ID: Int!\n  SERVICE_PROVIDER_NAME: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_PROVIDERInput {\n  SERVICE_PROVIDER_ID: Int!\n}\n\ninput CreateSORT_CRITERIAInput {\n  ORIGIN_PRODUCT_ID: Int!\n  STEP_TYPE_ID: Int!\n  JSON_PATH: String!\n  SORT_ORDER: String!\n  SORT_PRIORITY: Int!\n  SEQUENCE_NBR: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput UpdateSORT_CRITERIAInput {\n  SORT_CRITERIA_ID: Int!\n  ORIGIN_PRODUCT_ID: Int\n  STEP_TYPE_ID: Int\n  JSON_PATH: String\n  SORT_ORDER: String\n  SORT_PRIORITY: Int\n  SEQUENCE_NBR: Int\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteSORT_CRITERIAInput {\n  SORT_CRITERIA_ID: Int!\n}\n\ninput CreateSTEP_SERVICE_MAPPINGInput {\n  STEP_TYPE_ID: Int!\n  SERVICE_ID: Int!\n  SEQUENCE_NBR: Int\n}\n\ninput UpdateSTEP_SERVICE_MAPPINGInput {\n  STEP_SERVICE_MAPPING_ID: Int!\n  STEP_TYPE_ID: Int\n  SERVICE_ID: Int\n  SEQUENCE_NBR: Int\n}\n\ninput DeleteSTEP_SERVICE_MAPPINGInput {\n  STEP_SERVICE_MAPPING_ID: Int!\n}\n\ninput CreateSTEP_TYPEInput {\n  STEP_TYPE_NAME: String!\n  STEP_TYPE_DESC: String\n  RESOURCE_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSTEP_TYPEInput {\n  STEP_TYPE_ID: Int!\n  STEP_TYPE_NAME: String\n  STEP_TYPE_DESC: String\n  RESOURCE_NAME: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSTEP_TYPEInput {\n  STEP_TYPE_ID: Int!\n}\n\ninput CreateSTEP_TYPE_PARAM_MAPInput {\n  STEP_TYPE_ID: Int\n  SERVICE_PARAM_MAPPING_ID: Int!\n  CREATED_BY_USER_ID: String\n  CREATED_DATE: String\n}\n\ninput UpdateSTEP_TYPE_PARAM_MAPInput {\n  STEP_TYPE_PARAM_MAP_ID: Int!\n  STEP_TYPE_ID: Int\n  SERVICE_PARAM_MAPPING_ID: Int\n  CREATED_BY_USER_ID: String\n  CREATED_DATE: String\n}\n\ninput DeleteSTEP_TYPE_PARAM_MAPInput {\n  STEP_TYPE_PARAM_MAP_ID: Int!\n}\n\ntype CONFIG_PARAMConnection {\n  items: [CONFIG_PARAM]\n  nextToken: String\n}\n\ntype FILTER_CRITERIAConnection {\n  items: [FILTER_CRITERIA]\n  nextToken: String\n}\n\ntype LOAN_APPConnection {\n  items: [LOAN_APP]\n  nextToken: String\n}\n\ntype LOAN_APP_EXECSConnection {\n  items: [LOAN_APP_EXECS]\n  nextToken: String\n}\n\ntype LOAN_APP_STEP_STATUSConnection {\n  items: [LOAN_APP_STEP_STATUS]\n  nextToken: String\n}\n\ntype NEW_MEMBER_TOKENConnection {\n  items: [NEW_MEMBER_TOKEN]\n  nextToken: String\n}\n\ntype ORIGIN_PRODUCTConnection {\n  items: [ORIGIN_PRODUCT]\n  nextToken: String\n}\n\ntype REDIRECT_URLConnection {\n  items: [REDIRECT_URL]\n  nextToken: String\n}\n\ntype SERVICEConnection {\n  items: [SERVICE]\n  nextToken: String\n}\n\ntype SERVICE_DOMAINConnection {\n  items: [SERVICE_DOMAIN]\n  nextToken: String\n}\n\ntype SERVICE_EXPR_MAPPINGConnection {\n  items: [SERVICE_EXPR_MAPPING]\n  nextToken: String\n}\n\ntype SERVICE_PARAMConnection {\n  items: [SERVICE_PARAM]\n  nextToken: String\n}\n\ntype SERVICE_PARAM_MAPPINGConnection {\n  items: [SERVICE_PARAM_MAPPING]\n  nextToken: String\n}\n\ntype SERVICE_PROVIDERConnection {\n  items: [SERVICE_PROVIDER]\n  nextToken: String\n}\n\ntype SORT_CRITERIAConnection {\n  items: [SORT_CRITERIA]\n  nextToken: String\n}\n\ntype STEP_SERVICE_MAPPINGConnection {\n  items: [STEP_SERVICE_MAPPING]\n  nextToken: String\n}\n\ntype STEP_TYPEConnection {\n  items: [STEP_TYPE]\n  nextToken: String\n}\n\ntype STEP_TYPE_PARAM_MAPConnection {\n  items: [STEP_TYPE_PARAM_MAP]\n  nextToken: String\n}\n\ntype Query {\n  listCONFIG_PARAMS: CONFIG_PARAMConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listFILTER_CRITERIAS: FILTER_CRITERIAConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listLOAN_APPS: LOAN_APPConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listLOAN_APP_EXECS: LOAN_APP_EXECSConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listLOAN_APP_STEP_STATUS: LOAN_APP_STEP_STATUSConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listNEW_MEMBER_TOKENS: NEW_MEMBER_TOKENConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listORIGIN_PRODUCTS: ORIGIN_PRODUCTConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listREDIRECT_URLS: REDIRECT_URLConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICES: SERVICEConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_DOMAINS: SERVICE_DOMAINConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_EXPR_MAPPINGS: SERVICE_EXPR_MAPPINGConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_PARAMS: SERVICE_PARAMConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_PARAM_MAPPINGS: SERVICE_PARAM_MAPPINGConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_PROVIDERS: SERVICE_PROVIDERConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSORT_CRITERIAS: SORT_CRITERIAConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSTEP_SERVICE_MAPPINGS: STEP_SERVICE_MAPPINGConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSTEP_TYPES: STEP_TYPEConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSTEP_TYPE_PARAM_MAPS: STEP_TYPE_PARAM_MAPConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n}\n\ntype Mutation {\n  createCONFIG_PARAM(input: CreateCONFIG_PARAMInput!): CONFIG_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateCONFIG_PARAM(input: UpdateCONFIG_PARAMInput!): CONFIG_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteCONFIG_PARAM(input: DeleteCONFIG_PARAMInput!): CONFIG_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createFILTER_CRITERIA(input: CreateFILTER_CRITERIAInput!): FILTER_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateFILTER_CRITERIA(input: UpdateFILTER_CRITERIAInput!): FILTER_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteFILTER_CRITERIA(input: DeleteFILTER_CRITERIAInput!): FILTER_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createORIGIN_PRODUCT(input: CreateORIGIN_PRODUCTInput!): ORIGIN_PRODUCT @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateORIGIN_PRODUCT(input: UpdateORIGIN_PRODUCTInput!): ORIGIN_PRODUCT @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteORIGIN_PRODUCT(input: DeleteORIGIN_PRODUCTInput!): ORIGIN_PRODUCT @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createREDIRECT_URL(input: CreateREDIRECT_URLInput!): REDIRECT_URL @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateREDIRECT_URL(input: UpdateREDIRECT_URLInput!): REDIRECT_URL @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteREDIRECT_URL(input: DeleteREDIRECT_URLInput!): REDIRECT_URL @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE(input: CreateSERVICEInput!): SERVICE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE(input: UpdateSERVICEInput!): SERVICE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE(input: DeleteSERVICEInput!): SERVICE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_DOMAIN(input: CreateSERVICE_DOMAINInput!): SERVICE_DOMAIN @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_DOMAIN(input: UpdateSERVICE_DOMAINInput!): SERVICE_DOMAIN @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_DOMAIN(input: DeleteSERVICE_DOMAINInput!): SERVICE_DOMAIN @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_EXPR_MAPPING(input: CreateSERVICE_EXPR_MAPPINGInput!): SERVICE_EXPR_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_EXPR_MAPPING(input: UpdateSERVICE_EXPR_MAPPINGInput!): SERVICE_EXPR_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_EXPR_MAPPING(input: DeleteSERVICE_EXPR_MAPPINGInput!): SERVICE_EXPR_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_PARAM(input: CreateSERVICE_PARAMInput!): SERVICE_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_PARAM(input: UpdateSERVICE_PARAMInput!): SERVICE_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_PARAM(input: DeleteSERVICE_PARAMInput!): SERVICE_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_PARAM_MAPPING(input: CreateSERVICE_PARAM_MAPPINGInput!): SERVICE_PARAM_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_PARAM_MAPPING(input: UpdateSERVICE_PARAM_MAPPINGInput!): SERVICE_PARAM_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_PARAM_MAPPING(input: DeleteSERVICE_PARAM_MAPPINGInput!): SERVICE_PARAM_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_PROVIDER(input: CreateSERVICE_PROVIDERInput!): SERVICE_PROVIDER @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_PROVIDER(input: UpdateSERVICE_PROVIDERInput!): SERVICE_PROVIDER @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_PROVIDER(input: DeleteSERVICE_PROVIDERInput!): SERVICE_PROVIDER @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSORT_CRITERIA(input: CreateSORT_CRITERIAInput!): SORT_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSORT_CRITERIA(input: UpdateSORT_CRITERIAInput!): SORT_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSORT_CRITERIA(input: DeleteSORT_CRITERIAInput!): SORT_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSTEP_SERVICE_MAPPING(input: CreateSTEP_SERVICE_MAPPINGInput!): STEP_SERVICE_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSTEP_SERVICE_MAPPING(input: UpdateSTEP_SERVICE_MAPPINGInput!): STEP_SERVICE_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSTEP_SERVICE_MAPPING(input: DeleteSTEP_SERVICE_MAPPINGInput!): STEP_SERVICE_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSTEP_TYPE(input: CreateSTEP_TYPEInput!): STEP_TYPE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSTEP_TYPE(input: UpdateSTEP_TYPEInput!): STEP_TYPE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSTEP_TYPE(input: DeleteSTEP_TYPEInput!): STEP_TYPE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSTEP_TYPE_PARAM_MAP(input: CreateSTEP_TYPE_PARAM_MAPInput!): STEP_TYPE_PARAM_MAP @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSTEP_TYPE_PARAM_MAP(input: UpdateSTEP_TYPE_PARAM_MAPInput!): STEP_TYPE_PARAM_MAP @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSTEP_TYPE_PARAM_MAP(input: DeleteSTEP_TYPE_PARAM_MAPInput!): STEP_TYPE_PARAM_MAP @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n}\n\ntype Subscription {\n  onCreateCONFIG_PARAM: CONFIG_PARAM\n  onCreateLOAN_APP: LOAN_APP\n  onCreateNEW_MEMBER_TOKEN: NEW_MEMBER_TOKEN\n  onCreateORIGIN_PRODUCT: ORIGIN_PRODUCT\n}",
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        }
      }
    },
    "GraphQlDsStageDataSource": {
      "Type": "AWS::AppSync::DataSource",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "Name": "StageDataSource",
        "Type": "RELATIONAL_DATABASE",
        "ServiceRoleArn": {
          "Fn::GetAtt": [
            "RDSServiceRole",
            "Arn"
          ]
        },
        "RelationalDatabaseConfig": {
          "RdsHttpEndpointConfig": {
            "AwsRegion": "us-east-2",
            "DbClusterIdentifier": {
              "Fn::Join": [
                ":",
                [
                  "arn",
                  "aws",
                  "rds",
                  "us-east-2",
                  {
                    "Ref": "AWS::AccountId"
                  },
                  "cluster",
                  "hazel-mapping"
                ]
              ]
            },
            "DatabaseName": "hazel_mapping_dev",
            "AwsSecretStoreArn": "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-a11d98c5-d647-45a2-9978-f81be7aa3d60-iDsvX3"
          },
          "RelationalDatabaseSourceType": "RDS_HTTP_ENDPOINT"
        }
      }
    },
    "GraphQlResolverMutationcreateCONFIGPARAM": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createCONFIG_PARAM",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO CONFIG_PARAM\n    (CONFIG_NAME, CONFIG_VALUE, DESCRIPTION, CREATED_DATE, CHANGED_DATE)\n  VALUES\n    (:CONFIG_NAME, :CONFIG_VALUE, :DESCRIPTION, COALESCE(:CREATED_DATE, NOW()), :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    CONFIG_PARAM_ID, CONFIG_NAME, CONFIG_VALUE, DESCRIPTION, CREATED_DATE, CHANGED_DATE\n  FROM CONFIG_PARAM\n  WHERE CONFIG_NAME = :CONFIG_NAME\n  ORDER BY CONFIG_PARAM_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":CONFIG_NAME\": $util.toJson($ctx.args.input.CONFIG_NAME),\n    \":CONFIG_VALUE\": $util.toJson($ctx.args.input.CONFIG_VALUE),\n    \":DESCRIPTION\": $util.toJson($util.defaultIfNull($ctx.args.input.DESCRIPTION, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateFILTERCRITERIA": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createFILTER_CRITERIA",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO FILTER_CRITERIA\n    (ORIGIN_PRODUCT_ID, STEP_TYPE_ID, CRITERIA, SEQUENCE_NBR, CREATED_DATE, CHANGED_DATE)\n  VALUES\n    (:ORIGIN_PRODUCT_ID, :STEP_TYPE_ID, :CRITERIA, :SEQUENCE_NBR, COALESCE(:CREATED_DATE, NOW()), :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    FILTER_CRITERIA_ID, ORIGIN_PRODUCT_ID, STEP_TYPE_ID, CRITERIA, SEQUENCE_NBR, CREATED_DATE, CHANGED_DATE\n  FROM FILTER_CRITERIA\n  WHERE CRITERIA = :CRITERIA\n  ORDER BY FILTER_CRITERIA_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($ctx.args.input.ORIGIN_PRODUCT_ID),\n    \":STEP_TYPE_ID\": $util.toJson($ctx.args.input.STEP_TYPE_ID),\n    \":CRITERIA\": $util.toJson($ctx.args.input.CRITERIA),\n    \":SEQUENCE_NBR\": $util.toJson($ctx.args.input.SEQUENCE_NBR),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateORIGINPRODUCT": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createORIGIN_PRODUCT",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO ORIGIN_PRODUCT\n    (VENDOR_NAME, PRODUCT_ID, PSCU_CLIENT_ID, PRODUCT_DESC, PARTNER_CODE, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE)\n  VALUES\n    (:VENDOR_NAME, :PRODUCT_ID, :PSCU_CLIENT_ID, :PRODUCT_DESC, :PARTNER_CODE, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_BY_USER_ID, :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    ORIGIN_PRODUCT_ID, VENDOR_NAME, PRODUCT_ID, PSCU_CLIENT_ID, PRODUCT_DESC, PARTNER_CODE, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM ORIGIN_PRODUCT\n  WHERE VENDOR_NAME = :VENDOR_NAME\n  ORDER BY ORIGIN_PRODUCT_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":VENDOR_NAME\": $util.toJson($ctx.args.input.VENDOR_NAME),\n    \":PRODUCT_ID\": $util.toJson($ctx.args.input.PRODUCT_ID),\n    \":PSCU_CLIENT_ID\": $util.toJson($ctx.args.input.PSCU_CLIENT_ID),\n    \":PRODUCT_DESC\": $util.toJson($ctx.args.input.PRODUCT_DESC),\n    \":PARTNER_CODE\": $util.toJson($util.defaultIfNull($ctx.args.input.PARTNER_CODE, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateREDIRECTURL": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createREDIRECT_URL",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO REDIRECT_URL\n    (ORIGIN_PRODUCT_ID, URL_TYPE_CODE, URL, RESPONSE_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE)\n  VALUES\n    (:ORIGIN_PRODUCT_ID, :URL_TYPE_CODE, :URL, :RESPONSE_TEXT, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_BY_USER_ID, :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    REDIRECT_URL_ID, ORIGIN_PRODUCT_ID, URL_TYPE_CODE, URL, RESPONSE_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM REDIRECT_URL\n  WHERE URL_TYPE_CODE = :URL_TYPE_CODE\n  ORDER BY REDIRECT_URL_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($ctx.args.input.ORIGIN_PRODUCT_ID),\n    \":URL_TYPE_CODE\": $util.toJson($ctx.args.input.URL_TYPE_CODE),\n    \":URL\": $util.toJson($ctx.args.input.URL),\n    \":RESPONSE_TEXT\": $util.toJson($util.defaultIfNull($ctx.args.input.RESPONSE_TEXT, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSERVICE": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSERVICE",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO SERVICE\n    (SERVICE_PROVIDER_ID, URI, SECRET_NAME, REQUEST_TYPE, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE)\n  VALUES\n    (:SERVICE_PROVIDER_ID, :URI, :SECRET_NAME, :REQUEST_TYPE, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_BY_USER_ID, :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    SERVICE_ID, SERVICE_PROVIDER_ID, URI, SECRET_NAME, REQUEST_TYPE, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE\n  WHERE SERVICE_PROVIDER_ID = :SERVICE_PROVIDER_ID AND URI = :URI\n  ORDER BY SERVICE_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PROVIDER_ID\": $util.toJson($ctx.args.input.SERVICE_PROVIDER_ID),\n    \":URI\": $util.toJson($ctx.args.input.URI),\n    \":SECRET_NAME\": $util.toJson($util.defaultIfNull($ctx.args.input.SECRET_NAME, null)),\n    \":REQUEST_TYPE\": $util.toJson($util.defaultIfNull($ctx.args.input.REQUEST_TYPE, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSERVICEDOMAIN": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSERVICE_DOMAIN",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO SERVICE_DOMAIN\n    (DOMAIN_URL, SERVICE_PROVIDER_ID, CREATED_DATE, CHANGED_DATE)\n  VALUES\n    (:DOMAIN_URL, :SERVICE_PROVIDER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    SERVICE_DOMAIN_ID, DOMAIN_URL, SERVICE_PROVIDER_ID, CREATED_DATE, CHANGED_DATE\n  FROM SERVICE_DOMAIN\n  WHERE DOMAIN_URL = :DOMAIN_URL\n  ORDER BY SERVICE_DOMAIN_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":DOMAIN_URL\": $util.toJson($util.defaultIfNull($ctx.args.input.DOMAIN_URL, null)),\n    \":SERVICE_PROVIDER_ID\": $util.toJson($ctx.args.input.SERVICE_PROVIDER_ID),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSERVICEEXPRMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSERVICE_EXPR_MAPPING",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO SERVICE_EXPR_MAPPING\n    (SERVICE_PARAM_MAPPING_ID, SOURCE_EXPR, TARGET_EXPR, COMMENT_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE)\n  VALUES\n    (:SERVICE_PARAM_MAPPING_ID, :SOURCE_EXPR, :TARGET_EXPR, :COMMENT_TEXT, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_BY_USER_ID, :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    SERVICE_EXPR_MAPPING_ID, SERVICE_PARAM_MAPPING_ID, SOURCE_EXPR, TARGET_EXPR, COMMENT_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_EXPR_MAPPING\n  WHERE SOURCE_EXPR = :SOURCE_EXPR\n  ORDER BY SERVICE_EXPR_MAPPING_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PARAM_MAPPING_ID\": $util.toJson($ctx.args.input.SERVICE_PARAM_MAPPING_ID),\n    \":SOURCE_EXPR\": $util.toJson($util.defaultIfNull($ctx.args.input.SOURCE_EXPR, null)),\n    \":TARGET_EXPR\": $util.toJson($util.defaultIfNull($ctx.args.input.TARGET_EXPR, null)),\n    \":COMMENT_TEXT\": $util.toJson($util.defaultIfNull($ctx.args.input.COMMENT_TEXT, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSERVICEPARAM": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSERVICE_PARAM",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO SERVICE_PARAM\n    (SERVICE_ID, PARAM_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE)\n  VALUES\n    (:SERVICE_ID, :PARAM_NAME, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_BY_USER_ID, :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    SERVICE_PARAM_ID, SERVICE_ID, PARAM_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PARAM\n  WHERE PARAM_NAME = :PARAM_NAME\n  ORDER BY SERVICE_PARAM_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_ID\": $util.toJson($ctx.args.input.SERVICE_ID),\n    \":PARAM_NAME\": $util.toJson($ctx.args.input.PARAM_NAME),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSERVICEPARAMMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSERVICE_PARAM_MAPPING",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO SERVICE_PARAM_MAPPING\n    (ORIGIN_PRODUCT_ID, SYSTEM_NBR, PRIN_NBR, AGENT_NBR, SOURCE_SERVICE_PARAM_ID, TARGET_SERVICE_PARAM_ID, PLASTIC_TYPE_ID, COMMENT_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE)\n  VALUES\n    (:ORIGIN_PRODUCT_ID, :SYSTEM_NBR, :PRIN_NBR, :AGENT_NBR, :SOURCE_SERVICE_PARAM_ID, :TARGET_SERVICE_PARAM_ID, :PLASTIC_TYPE_ID, :COMMENT_TEXT, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_BY_USER_ID, :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    SERVICE_PARAM_MAPPING_ID, ORIGIN_PRODUCT_ID, SYSTEM_NBR, PRIN_NBR, AGENT_NBR, SOURCE_SERVICE_PARAM_ID, TARGET_SERVICE_PARAM_ID, PLASTIC_TYPE_ID, COMMENT_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PARAM_MAPPING\n  WHERE ORIGIN_PRODUCT_ID = :ORIGIN_PRODUCT_ID AND SOURCE_SERVICE_PARAM_ID = :SOURCE_SERVICE_PARAM_ID AND TARGET_SERVICE_PARAM_ID = :TARGET_SERVICE_PARAM_ID\n  ORDER BY SERVICE_PARAM_MAPPING_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($ctx.args.input.ORIGIN_PRODUCT_ID),\n    \":SYSTEM_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.SYSTEM_NBR, null)),\n    \":PRIN_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.PRIN_NBR, null)),\n    \":AGENT_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.AGENT_NBR, null)),\n    \":SOURCE_SERVICE_PARAM_ID\": $util.toJson($ctx.args.input.SOURCE_SERVICE_PARAM_ID),\n    \":TARGET_SERVICE_PARAM_ID\": $util.toJson($ctx.args.input.TARGET_SERVICE_PARAM_ID),\n    \":PLASTIC_TYPE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.PLASTIC_TYPE_ID, null)),\n    \":COMMENT_TEXT\": $util.toJson($util.defaultIfNull($ctx.args.input.COMMENT_TEXT, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSERVICEPROVIDER": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSERVICE_PROVIDER",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO SERVICE_PROVIDER\n    (SERVICE_PROVIDER_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE)\n  VALUES\n    (:SERVICE_PROVIDER_NAME, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_BY_USER_ID, :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    SERVICE_PROVIDER_ID, SERVICE_PROVIDER_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PROVIDER\n  WHERE SERVICE_PROVIDER_NAME = :SERVICE_PROVIDER_NAME\n  ORDER BY SERVICE_PROVIDER_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PROVIDER_NAME\": $util.toJson($ctx.args.input.SERVICE_PROVIDER_NAME),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSORTCRITERIA": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSORT_CRITERIA",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO SORT_CRITERIA\n    (ORIGIN_PRODUCT_ID, STEP_TYPE_ID, JSON_PATH, SORT_ORDER, SORT_PRIORITY, SEQUENCE_NBR, CREATED_DATE, CHANGED_DATE)\n  VALUES\n    (:ORIGIN_PRODUCT_ID, :STEP_TYPE_ID, :JSON_PATH, :SORT_ORDER, :SORT_PRIORITY, :SEQUENCE_NBR, COALESCE(:CREATED_DATE, NOW()), :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    SORT_CRITERIA_ID, ORIGIN_PRODUCT_ID, STEP_TYPE_ID, JSON_PATH, SORT_ORDER, SORT_PRIORITY, SEQUENCE_NBR, CREATED_DATE, CHANGED_DATE\n  FROM SORT_CRITERIA\n  WHERE JSON_PATH = :JSON_PATH\n  ORDER BY SORT_CRITERIA_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($ctx.args.input.ORIGIN_PRODUCT_ID),\n    \":STEP_TYPE_ID\": $util.toJson($ctx.args.input.STEP_TYPE_ID),\n    \":JSON_PATH\": $util.toJson($ctx.args.input.JSON_PATH),\n    \":SORT_ORDER\": $util.toJson($ctx.args.input.SORT_ORDER),\n    \":SORT_PRIORITY\": $util.toJson($ctx.args.input.SORT_PRIORITY),\n    \":SEQUENCE_NBR\": $util.toJson($ctx.args.input.SEQUENCE_NBR),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSTEPSERVICEMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSTEP_SERVICE_MAPPING",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO STEP_SERVICE_MAPPING\n    (STEP_TYPE_ID, SERVICE_ID, SEQUENCE_NBR)\n  VALUES\n    (:STEP_TYPE_ID, :SERVICE_ID, :SEQUENCE_NBR)\n\")\n#set($select = \"\n  SELECT\n    STEP_SERVICE_MAPPING_ID, STEP_TYPE_ID, SERVICE_ID, SEQUENCE_NBR\n  FROM STEP_SERVICE_MAPPING\n  WHERE SEQUENCE_NBR = :SEQUENCE_NBR\n  ORDER BY STEP_SERVICE_MAPPING_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":STEP_TYPE_ID\": $util.toJson($ctx.args.input.STEP_TYPE_ID),\n    \":SERVICE_ID\": $util.toJson($ctx.args.input.SERVICE_ID),\n    \":SEQUENCE_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.SEQUENCE_NBR, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSTEPTYPE": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSTEP_TYPE",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO STEP_TYPE\n    (STEP_TYPE_NAME, STEP_TYPE_DESC, RESOURCE_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE)\n  VALUES\n    (:STEP_TYPE_NAME, :STEP_TYPE_DESC, :RESOURCE_NAME, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()), :CHANGED_BY_USER_ID, :CHANGED_DATE)\n\")\n#set($select = \"\n  SELECT\n    STEP_TYPE_ID, STEP_TYPE_NAME, STEP_TYPE_DESC, RESOURCE_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM STEP_TYPE\n  WHERE STEP_TYPE_NAME = :STEP_TYPE_NAME\n  ORDER BY STEP_TYPE_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":STEP_TYPE_NAME\": $util.toJson($ctx.args.input.STEP_TYPE_NAME),\n    \":STEP_TYPE_DESC\": $util.toJson($util.defaultIfNull($ctx.args.input.STEP_TYPE_DESC, null)),\n    \":RESOURCE_NAME\": $util.toJson($ctx.args.input.RESOURCE_NAME),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationcreateSTEPTYPEPARAMMAP": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "createSTEP_TYPE_PARAM_MAP",
        "RequestMappingTemplate": "#set($insert = \"\n  INSERT INTO STEP_TYPE_PARAM_MAP\n    (STEP_TYPE_ID, SERVICE_PARAM_MAPPING_ID, CREATED_BY_USER_ID, CREATED_DATE)\n  VALUES\n    (:STEP_TYPE_ID, :SERVICE_PARAM_MAPPING_ID, :CREATED_BY_USER_ID, COALESCE(:CREATED_DATE, NOW()))\n\")\n#set($select = \"\n  SELECT\n    STEP_TYPE_PARAM_MAP_ID, STEP_TYPE_ID, SERVICE_PARAM_MAPPING_ID, CREATED_BY_USER_ID, CREATED_DATE\n  FROM STEP_TYPE_PARAM_MAP\n  WHERE STEP_TYPE_ID = :STEP_TYPE_ID AND SERVICE_PARAM_MAPPING_ID = :SERVICE_PARAM_MAPPING_ID\n  ORDER BY STEP_TYPE_PARAM_MAP_ID DESC\n  LIMIT 1\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($insert)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":STEP_TYPE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.STEP_TYPE_ID, null)),\n    \":SERVICE_PARAM_MAPPING_ID\": $util.toJson($ctx.args.input.SERVICE_PARAM_MAPPING_ID),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"Create succeeded but no row was returned by SELECT.\", \"NotFound\")\n#end\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteCONFIGPARAM": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteCONFIG_PARAM",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT CONFIG_PARAM_ID, CONFIG_NAME, CONFIG_VALUE, DESCRIPTION, CREATED_DATE, CHANGED_DATE\n  FROM CONFIG_PARAM\n  WHERE CONFIG_PARAM_ID = :CONFIG_PARAM_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM CONFIG_PARAM\n  WHERE CONFIG_PARAM_ID = :CONFIG_PARAM_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":CONFIG_PARAM_ID\": $util.toJson($ctx.args.input.CONFIG_PARAM_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for CONFIG_PARAM_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteFILTERCRITERIA": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteFILTER_CRITERIA",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT FILTER_CRITERIA_ID, ORIGIN_PRODUCT_ID, STEP_TYPE_ID, CRITERIA, SEQUENCE_NBR, CREATED_DATE, CHANGED_DATE\n  FROM FILTER_CRITERIA\n  WHERE FILTER_CRITERIA_ID = :FILTER_CRITERIA_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM FILTER_CRITERIA\n  WHERE FILTER_CRITERIA_ID = :FILTER_CRITERIA_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":FILTER_CRITERIA_ID\": $util.toJson($ctx.args.input.FILTER_CRITERIA_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for FILTER_CRITERIA_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteORIGINPRODUCT": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteORIGIN_PRODUCT",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT ORIGIN_PRODUCT_ID, VENDOR_NAME, PRODUCT_ID, PSCU_CLIENT_ID, PRODUCT_DESC, PARTNER_CODE, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM ORIGIN_PRODUCT\n  WHERE ORIGIN_PRODUCT_ID = :ORIGIN_PRODUCT_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM ORIGIN_PRODUCT\n  WHERE ORIGIN_PRODUCT_ID = :ORIGIN_PRODUCT_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($ctx.args.input.ORIGIN_PRODUCT_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for ORIGIN_PRODUCT_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteREDIRECTURL": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteREDIRECT_URL",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT REDIRECT_URL_ID, ORIGIN_PRODUCT_ID, URL_TYPE_CODE, URL, RESPONSE_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM REDIRECT_URL\n  WHERE REDIRECT_URL_ID = :REDIRECT_URL_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM REDIRECT_URL\n  WHERE REDIRECT_URL_ID = :REDIRECT_URL_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":REDIRECT_URL_ID\": $util.toJson($ctx.args.input.REDIRECT_URL_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for REDIRECT_URL_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSERVICE": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSERVICE",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT SERVICE_ID, SERVICE_PROVIDER_ID, URI, SECRET_NAME, REQUEST_TYPE, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE\n  WHERE SERVICE_ID = :SERVICE_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM SERVICE\n  WHERE SERVICE_ID = :SERVICE_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_ID\": $util.toJson($ctx.args.input.SERVICE_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for SERVICE_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSERVICEDOMAIN": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSERVICE_DOMAIN",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT SERVICE_DOMAIN_ID, DOMAIN_URL, SERVICE_PROVIDER_ID, CREATED_DATE, CHANGED_DATE\n  FROM SERVICE_DOMAIN\n  WHERE SERVICE_DOMAIN_ID = :SERVICE_DOMAIN_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM SERVICE_DOMAIN\n  WHERE SERVICE_DOMAIN_ID = :SERVICE_DOMAIN_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_DOMAIN_ID\": $util.toJson($ctx.args.input.SERVICE_DOMAIN_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for SERVICE_DOMAIN_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSERVICEEXPRMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSERVICE_EXPR_MAPPING",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT SERVICE_EXPR_MAPPING_ID, SERVICE_PARAM_MAPPING_ID, SOURCE_EXPR, TARGET_EXPR, COMMENT_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_EXPR_MAPPING\n  WHERE SERVICE_EXPR_MAPPING_ID = :SERVICE_EXPR_MAPPING_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM SERVICE_EXPR_MAPPING\n  WHERE SERVICE_EXPR_MAPPING_ID = :SERVICE_EXPR_MAPPING_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_EXPR_MAPPING_ID\": $util.toJson($ctx.args.input.SERVICE_EXPR_MAPPING_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for SERVICE_EXPR_MAPPING_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSERVICEPARAM": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSERVICE_PARAM",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT SERVICE_PARAM_ID, SERVICE_ID, PARAM_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PARAM\n  WHERE SERVICE_PARAM_ID = :SERVICE_PARAM_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM SERVICE_PARAM\n  WHERE SERVICE_PARAM_ID = :SERVICE_PARAM_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PARAM_ID\": $util.toJson($ctx.args.input.SERVICE_PARAM_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for SERVICE_PARAM_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSERVICEPARAMMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSERVICE_PARAM_MAPPING",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT SERVICE_PARAM_MAPPING_ID, ORIGIN_PRODUCT_ID, SYSTEM_NBR, PRIN_NBR, AGENT_NBR, SOURCE_SERVICE_PARAM_ID, TARGET_SERVICE_PARAM_ID, PLASTIC_TYPE_ID, COMMENT_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PARAM_MAPPING\n  WHERE SERVICE_PARAM_MAPPING_ID = :SERVICE_PARAM_MAPPING_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM SERVICE_PARAM_MAPPING\n  WHERE SERVICE_PARAM_MAPPING_ID = :SERVICE_PARAM_MAPPING_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PARAM_MAPPING_ID\": $util.toJson($ctx.args.input.SERVICE_PARAM_MAPPING_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for SERVICE_PARAM_MAPPING_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSERVICEPROVIDER": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSERVICE_PROVIDER",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT SERVICE_PROVIDER_ID, SERVICE_PROVIDER_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PROVIDER\n  WHERE SERVICE_PROVIDER_ID = :SERVICE_PROVIDER_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM SERVICE_PROVIDER\n  WHERE SERVICE_PROVIDER_ID = :SERVICE_PROVIDER_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PROVIDER_ID\": $util.toJson($ctx.args.input.SERVICE_PROVIDER_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for SERVICE_PROVIDER_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSORTCRITERIA": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSORT_CRITERIA",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT SORT_CRITERIA_ID, ORIGIN_PRODUCT_ID, STEP_TYPE_ID, JSON_PATH, SORT_ORDER, SORT_PRIORITY, SEQUENCE_NBR, CREATED_DATE, CHANGED_DATE\n  FROM SORT_CRITERIA\n  WHERE SORT_CRITERIA_ID = :SORT_CRITERIA_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM SORT_CRITERIA\n  WHERE SORT_CRITERIA_ID = :SORT_CRITERIA_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":SORT_CRITERIA_ID\": $util.toJson($ctx.args.input.SORT_CRITERIA_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for SORT_CRITERIA_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSTEPSERVICEMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSTEP_SERVICE_MAPPING",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT STEP_SERVICE_MAPPING_ID, STEP_TYPE_ID, SERVICE_ID, SEQUENCE_NBR\n  FROM STEP_SERVICE_MAPPING\n  WHERE STEP_SERVICE_MAPPING_ID = :STEP_SERVICE_MAPPING_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM STEP_SERVICE_MAPPING\n  WHERE STEP_SERVICE_MAPPING_ID = :STEP_SERVICE_MAPPING_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":STEP_SERVICE_MAPPING_ID\": $util.toJson($ctx.args.input.STEP_SERVICE_MAPPING_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for STEP_SERVICE_MAPPING_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSTEPTYPE": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSTEP_TYPE",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT STEP_TYPE_ID, STEP_TYPE_NAME, STEP_TYPE_DESC, RESOURCE_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM STEP_TYPE\n  WHERE STEP_TYPE_ID = :STEP_TYPE_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM STEP_TYPE\n  WHERE STEP_TYPE_ID = :STEP_TYPE_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":STEP_TYPE_ID\": $util.toJson($ctx.args.input.STEP_TYPE_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for STEP_TYPE_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationdeleteSTEPTYPEPARAMMAP": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "deleteSTEP_TYPE_PARAM_MAP",
        "RequestMappingTemplate": "#set($preimage = \"\n  SELECT STEP_TYPE_PARAM_MAP_ID, STEP_TYPE_ID, SERVICE_PARAM_MAPPING_ID, CREATED_BY_USER_ID, CREATED_DATE\n  FROM STEP_TYPE_PARAM_MAP\n  WHERE STEP_TYPE_PARAM_MAP_ID = :STEP_TYPE_PARAM_MAP_ID\n  LIMIT 1\n\")\n#set($delete = \"\n  DELETE FROM STEP_TYPE_PARAM_MAP\n  WHERE STEP_TYPE_PARAM_MAP_ID = :STEP_TYPE_PARAM_MAP_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($preimage)\",\n    \"$util.escapeJavaScript($delete)\"\n  ],\n  \"variableMap\": {\n    \":STEP_TYPE_PARAM_MAP_ID\": $util.toJson($ctx.args.input.STEP_TYPE_PARAM_MAP_ID)\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows[0].size() == 0)\n  $util.error(\"Nothing to delete for STEP_TYPE_PARAM_MAP_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[0][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateCONFIGPARAM": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateCONFIG_PARAM",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE CONFIG_PARAM\n  SET CONFIG_NAME = COALESCE(:CONFIG_NAME, CONFIG_NAME), CONFIG_VALUE = COALESCE(:CONFIG_VALUE, CONFIG_VALUE), DESCRIPTION = COALESCE(:DESCRIPTION, DESCRIPTION), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE CONFIG_PARAM_ID = :CONFIG_PARAM_ID\n\")\n#set($select = \"\n  SELECT CONFIG_PARAM_ID, CONFIG_NAME, CONFIG_VALUE, DESCRIPTION, CREATED_DATE, CHANGED_DATE\n  FROM CONFIG_PARAM\n  WHERE CONFIG_PARAM_ID = :CONFIG_PARAM_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":CONFIG_PARAM_ID\": $util.toJson($ctx.args.input.CONFIG_PARAM_ID),\n    \":CONFIG_NAME\": $util.toJson($util.defaultIfNull($ctx.args.input.CONFIG_NAME, null)),\n    \":CONFIG_VALUE\": $util.toJson($util.defaultIfNull($ctx.args.input.CONFIG_VALUE, null)),\n    \":DESCRIPTION\": $util.toJson($util.defaultIfNull($ctx.args.input.DESCRIPTION, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for CONFIG_PARAM_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateFILTERCRITERIA": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateFILTER_CRITERIA",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE FILTER_CRITERIA\n  SET ORIGIN_PRODUCT_ID = COALESCE(:ORIGIN_PRODUCT_ID, ORIGIN_PRODUCT_ID), STEP_TYPE_ID = COALESCE(:STEP_TYPE_ID, STEP_TYPE_ID), CRITERIA = COALESCE(:CRITERIA, CRITERIA), SEQUENCE_NBR = COALESCE(:SEQUENCE_NBR, SEQUENCE_NBR), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE FILTER_CRITERIA_ID = :FILTER_CRITERIA_ID\n\")\n#set($select = \"\n  SELECT FILTER_CRITERIA_ID, ORIGIN_PRODUCT_ID, STEP_TYPE_ID, CRITERIA, SEQUENCE_NBR, CREATED_DATE, CHANGED_DATE\n  FROM FILTER_CRITERIA\n  WHERE FILTER_CRITERIA_ID = :FILTER_CRITERIA_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":FILTER_CRITERIA_ID\": $util.toJson($ctx.args.input.FILTER_CRITERIA_ID),\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.ORIGIN_PRODUCT_ID, null)),\n    \":STEP_TYPE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.STEP_TYPE_ID, null)),\n    \":CRITERIA\": $util.toJson($util.defaultIfNull($ctx.args.input.CRITERIA, null)),\n    \":SEQUENCE_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.SEQUENCE_NBR, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for FILTER_CRITERIA_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateORIGINPRODUCT": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateORIGIN_PRODUCT",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE ORIGIN_PRODUCT\n  SET VENDOR_NAME = COALESCE(:VENDOR_NAME, VENDOR_NAME), PRODUCT_ID = COALESCE(:PRODUCT_ID, PRODUCT_ID), PSCU_CLIENT_ID = COALESCE(:PSCU_CLIENT_ID, PSCU_CLIENT_ID), PRODUCT_DESC = COALESCE(:PRODUCT_DESC, PRODUCT_DESC), PARTNER_CODE = COALESCE(:PARTNER_CODE, PARTNER_CODE), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_BY_USER_ID = COALESCE(:CHANGED_BY_USER_ID, CHANGED_BY_USER_ID), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE ORIGIN_PRODUCT_ID = :ORIGIN_PRODUCT_ID\n\")\n#set($select = \"\n  SELECT ORIGIN_PRODUCT_ID, VENDOR_NAME, PRODUCT_ID, PSCU_CLIENT_ID, PRODUCT_DESC, PARTNER_CODE, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM ORIGIN_PRODUCT\n  WHERE ORIGIN_PRODUCT_ID = :ORIGIN_PRODUCT_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($ctx.args.input.ORIGIN_PRODUCT_ID),\n    \":VENDOR_NAME\": $util.toJson($util.defaultIfNull($ctx.args.input.VENDOR_NAME, null)),\n    \":PRODUCT_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.PRODUCT_ID, null)),\n    \":PSCU_CLIENT_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.PSCU_CLIENT_ID, null)),\n    \":PRODUCT_DESC\": $util.toJson($util.defaultIfNull($ctx.args.input.PRODUCT_DESC, null)),\n    \":PARTNER_CODE\": $util.toJson($util.defaultIfNull($ctx.args.input.PARTNER_CODE, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for ORIGIN_PRODUCT_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateREDIRECTURL": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateREDIRECT_URL",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE REDIRECT_URL\n  SET ORIGIN_PRODUCT_ID = COALESCE(:ORIGIN_PRODUCT_ID, ORIGIN_PRODUCT_ID), URL_TYPE_CODE = COALESCE(:URL_TYPE_CODE, URL_TYPE_CODE), URL = COALESCE(:URL, URL), RESPONSE_TEXT = COALESCE(:RESPONSE_TEXT, RESPONSE_TEXT), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_BY_USER_ID = COALESCE(:CHANGED_BY_USER_ID, CHANGED_BY_USER_ID), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE REDIRECT_URL_ID = :REDIRECT_URL_ID\n\")\n#set($select = \"\n  SELECT REDIRECT_URL_ID, ORIGIN_PRODUCT_ID, URL_TYPE_CODE, URL, RESPONSE_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM REDIRECT_URL\n  WHERE REDIRECT_URL_ID = :REDIRECT_URL_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":REDIRECT_URL_ID\": $util.toJson($ctx.args.input.REDIRECT_URL_ID),\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.ORIGIN_PRODUCT_ID, null)),\n    \":URL_TYPE_CODE\": $util.toJson($util.defaultIfNull($ctx.args.input.URL_TYPE_CODE, null)),\n    \":URL\": $util.toJson($util.defaultIfNull($ctx.args.input.URL, null)),\n    \":RESPONSE_TEXT\": $util.toJson($util.defaultIfNull($ctx.args.input.RESPONSE_TEXT, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for REDIRECT_URL_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSERVICE": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSERVICE",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE SERVICE\n  SET SERVICE_PROVIDER_ID = COALESCE(:SERVICE_PROVIDER_ID, SERVICE_PROVIDER_ID), URI = COALESCE(:URI, URI), SECRET_NAME = COALESCE(:SECRET_NAME, SECRET_NAME), REQUEST_TYPE = COALESCE(:REQUEST_TYPE, REQUEST_TYPE), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_BY_USER_ID = COALESCE(:CHANGED_BY_USER_ID, CHANGED_BY_USER_ID), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE SERVICE_ID = :SERVICE_ID\n\")\n#set($select = \"\n  SELECT SERVICE_ID, SERVICE_PROVIDER_ID, URI, SECRET_NAME, REQUEST_TYPE, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE\n  WHERE SERVICE_ID = :SERVICE_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_ID\": $util.toJson($ctx.args.input.SERVICE_ID),\n    \":SERVICE_PROVIDER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.SERVICE_PROVIDER_ID, null)),\n    \":URI\": $util.toJson($util.defaultIfNull($ctx.args.input.URI, null)),\n    \":SECRET_NAME\": $util.toJson($util.defaultIfNull($ctx.args.input.SECRET_NAME, null)),\n    \":REQUEST_TYPE\": $util.toJson($util.defaultIfNull($ctx.args.input.REQUEST_TYPE, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for SERVICE_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSERVICEDOMAIN": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSERVICE_DOMAIN",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE SERVICE_DOMAIN\n  SET DOMAIN_URL = COALESCE(:DOMAIN_URL, DOMAIN_URL), SERVICE_PROVIDER_ID = COALESCE(:SERVICE_PROVIDER_ID, SERVICE_PROVIDER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE SERVICE_DOMAIN_ID = :SERVICE_DOMAIN_ID\n\")\n#set($select = \"\n  SELECT SERVICE_DOMAIN_ID, DOMAIN_URL, SERVICE_PROVIDER_ID, CREATED_DATE, CHANGED_DATE\n  FROM SERVICE_DOMAIN\n  WHERE SERVICE_DOMAIN_ID = :SERVICE_DOMAIN_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_DOMAIN_ID\": $util.toJson($ctx.args.input.SERVICE_DOMAIN_ID),\n    \":DOMAIN_URL\": $util.toJson($util.defaultIfNull($ctx.args.input.DOMAIN_URL, null)),\n    \":SERVICE_PROVIDER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.SERVICE_PROVIDER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for SERVICE_DOMAIN_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSERVICEEXPRMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSERVICE_EXPR_MAPPING",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE SERVICE_EXPR_MAPPING\n  SET SERVICE_PARAM_MAPPING_ID = COALESCE(:SERVICE_PARAM_MAPPING_ID, SERVICE_PARAM_MAPPING_ID), SOURCE_EXPR = COALESCE(:SOURCE_EXPR, SOURCE_EXPR), TARGET_EXPR = COALESCE(:TARGET_EXPR, TARGET_EXPR), COMMENT_TEXT = COALESCE(:COMMENT_TEXT, COMMENT_TEXT), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_BY_USER_ID = COALESCE(:CHANGED_BY_USER_ID, CHANGED_BY_USER_ID), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE SERVICE_EXPR_MAPPING_ID = :SERVICE_EXPR_MAPPING_ID\n\")\n#set($select = \"\n  SELECT SERVICE_EXPR_MAPPING_ID, SERVICE_PARAM_MAPPING_ID, SOURCE_EXPR, TARGET_EXPR, COMMENT_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_EXPR_MAPPING\n  WHERE SERVICE_EXPR_MAPPING_ID = :SERVICE_EXPR_MAPPING_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_EXPR_MAPPING_ID\": $util.toJson($ctx.args.input.SERVICE_EXPR_MAPPING_ID),\n    \":SERVICE_PARAM_MAPPING_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.SERVICE_PARAM_MAPPING_ID, null)),\n    \":SOURCE_EXPR\": $util.toJson($util.defaultIfNull($ctx.args.input.SOURCE_EXPR, null)),\n    \":TARGET_EXPR\": $util.toJson($util.defaultIfNull($ctx.args.input.TARGET_EXPR, null)),\n    \":COMMENT_TEXT\": $util.toJson($util.defaultIfNull($ctx.args.input.COMMENT_TEXT, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for SERVICE_EXPR_MAPPING_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSERVICEPARAM": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSERVICE_PARAM",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE SERVICE_PARAM\n  SET SERVICE_ID = COALESCE(:SERVICE_ID, SERVICE_ID), PARAM_NAME = COALESCE(:PARAM_NAME, PARAM_NAME), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_BY_USER_ID = COALESCE(:CHANGED_BY_USER_ID, CHANGED_BY_USER_ID), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE SERVICE_PARAM_ID = :SERVICE_PARAM_ID\n\")\n#set($select = \"\n  SELECT SERVICE_PARAM_ID, SERVICE_ID, PARAM_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PARAM\n  WHERE SERVICE_PARAM_ID = :SERVICE_PARAM_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PARAM_ID\": $util.toJson($ctx.args.input.SERVICE_PARAM_ID),\n    \":SERVICE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.SERVICE_ID, null)),\n    \":PARAM_NAME\": $util.toJson($util.defaultIfNull($ctx.args.input.PARAM_NAME, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for SERVICE_PARAM_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSERVICEPARAMMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSERVICE_PARAM_MAPPING",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE SERVICE_PARAM_MAPPING\n  SET ORIGIN_PRODUCT_ID = COALESCE(:ORIGIN_PRODUCT_ID, ORIGIN_PRODUCT_ID), SYSTEM_NBR = COALESCE(:SYSTEM_NBR, SYSTEM_NBR), PRIN_NBR = COALESCE(:PRIN_NBR, PRIN_NBR), AGENT_NBR = COALESCE(:AGENT_NBR, AGENT_NBR), SOURCE_SERVICE_PARAM_ID = COALESCE(:SOURCE_SERVICE_PARAM_ID, SOURCE_SERVICE_PARAM_ID), TARGET_SERVICE_PARAM_ID = COALESCE(:TARGET_SERVICE_PARAM_ID, TARGET_SERVICE_PARAM_ID), PLASTIC_TYPE_ID = COALESCE(:PLASTIC_TYPE_ID, PLASTIC_TYPE_ID), COMMENT_TEXT = COALESCE(:COMMENT_TEXT, COMMENT_TEXT), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_BY_USER_ID = COALESCE(:CHANGED_BY_USER_ID, CHANGED_BY_USER_ID), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE SERVICE_PARAM_MAPPING_ID = :SERVICE_PARAM_MAPPING_ID\n\")\n#set($select = \"\n  SELECT SERVICE_PARAM_MAPPING_ID, ORIGIN_PRODUCT_ID, SYSTEM_NBR, PRIN_NBR, AGENT_NBR, SOURCE_SERVICE_PARAM_ID, TARGET_SERVICE_PARAM_ID, PLASTIC_TYPE_ID, COMMENT_TEXT, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PARAM_MAPPING\n  WHERE SERVICE_PARAM_MAPPING_ID = :SERVICE_PARAM_MAPPING_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PARAM_MAPPING_ID\": $util.toJson($ctx.args.input.SERVICE_PARAM_MAPPING_ID),\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.ORIGIN_PRODUCT_ID, null)),\n    \":SYSTEM_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.SYSTEM_NBR, null)),\n    \":PRIN_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.PRIN_NBR, null)),\n    \":AGENT_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.AGENT_NBR, null)),\n    \":SOURCE_SERVICE_PARAM_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.SOURCE_SERVICE_PARAM_ID, null)),\n    \":TARGET_SERVICE_PARAM_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.TARGET_SERVICE_PARAM_ID, null)),\n    \":PLASTIC_TYPE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.PLASTIC_TYPE_ID, null)),\n    \":COMMENT_TEXT\": $util.toJson($util.defaultIfNull($ctx.args.input.COMMENT_TEXT, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for SERVICE_PARAM_MAPPING_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSERVICEPROVIDER": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSERVICE_PROVIDER",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE SERVICE_PROVIDER\n  SET SERVICE_PROVIDER_NAME = COALESCE(:SERVICE_PROVIDER_NAME, SERVICE_PROVIDER_NAME), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_BY_USER_ID = COALESCE(:CHANGED_BY_USER_ID, CHANGED_BY_USER_ID), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE SERVICE_PROVIDER_ID = :SERVICE_PROVIDER_ID\n\")\n#set($select = \"\n  SELECT SERVICE_PROVIDER_ID, SERVICE_PROVIDER_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM SERVICE_PROVIDER\n  WHERE SERVICE_PROVIDER_ID = :SERVICE_PROVIDER_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SERVICE_PROVIDER_ID\": $util.toJson($ctx.args.input.SERVICE_PROVIDER_ID),\n    \":SERVICE_PROVIDER_NAME\": $util.toJson($util.defaultIfNull($ctx.args.input.SERVICE_PROVIDER_NAME, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for SERVICE_PROVIDER_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSORTCRITERIA": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSORT_CRITERIA",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE SORT_CRITERIA\n  SET ORIGIN_PRODUCT_ID = COALESCE(:ORIGIN_PRODUCT_ID, ORIGIN_PRODUCT_ID), STEP_TYPE_ID = COALESCE(:STEP_TYPE_ID, STEP_TYPE_ID), JSON_PATH = COALESCE(:JSON_PATH, JSON_PATH), SORT_ORDER = COALESCE(:SORT_ORDER, SORT_ORDER), SORT_PRIORITY = COALESCE(:SORT_PRIORITY, SORT_PRIORITY), SEQUENCE_NBR = COALESCE(:SEQUENCE_NBR, SEQUENCE_NBR), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE SORT_CRITERIA_ID = :SORT_CRITERIA_ID\n\")\n#set($select = \"\n  SELECT SORT_CRITERIA_ID, ORIGIN_PRODUCT_ID, STEP_TYPE_ID, JSON_PATH, SORT_ORDER, SORT_PRIORITY, SEQUENCE_NBR, CREATED_DATE, CHANGED_DATE\n  FROM SORT_CRITERIA\n  WHERE SORT_CRITERIA_ID = :SORT_CRITERIA_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":SORT_CRITERIA_ID\": $util.toJson($ctx.args.input.SORT_CRITERIA_ID),\n    \":ORIGIN_PRODUCT_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.ORIGIN_PRODUCT_ID, null)),\n    \":STEP_TYPE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.STEP_TYPE_ID, null)),\n    \":JSON_PATH\": $util.toJson($util.defaultIfNull($ctx.args.input.JSON_PATH, null)),\n    \":SORT_ORDER\": $util.toJson($util.defaultIfNull($ctx.args.input.SORT_ORDER, null)),\n    \":SORT_PRIORITY\": $util.toJson($util.defaultIfNull($ctx.args.input.SORT_PRIORITY, null)),\n    \":SEQUENCE_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.SEQUENCE_NBR, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for SORT_CRITERIA_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSTEPSERVICEMAPPING": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSTEP_SERVICE_MAPPING",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE STEP_SERVICE_MAPPING\n  SET STEP_TYPE_ID = COALESCE(:STEP_TYPE_ID, STEP_TYPE_ID), SERVICE_ID = COALESCE(:SERVICE_ID, SERVICE_ID), SEQUENCE_NBR = COALESCE(:SEQUENCE_NBR, SEQUENCE_NBR)\n  WHERE STEP_SERVICE_MAPPING_ID = :STEP_SERVICE_MAPPING_ID\n\")\n#set($select = \"\n  SELECT STEP_SERVICE_MAPPING_ID, STEP_TYPE_ID, SERVICE_ID, SEQUENCE_NBR\n  FROM STEP_SERVICE_MAPPING\n  WHERE STEP_SERVICE_MAPPING_ID = :STEP_SERVICE_MAPPING_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":STEP_SERVICE_MAPPING_ID\": $util.toJson($ctx.args.input.STEP_SERVICE_MAPPING_ID),\n    \":STEP_TYPE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.STEP_TYPE_ID, null)),\n    \":SERVICE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.SERVICE_ID, null)),\n    \":SEQUENCE_NBR\": $util.toJson($util.defaultIfNull($ctx.args.input.SEQUENCE_NBR, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for STEP_SERVICE_MAPPING_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSTEPTYPE": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSTEP_TYPE",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE STEP_TYPE\n  SET STEP_TYPE_NAME = COALESCE(:STEP_TYPE_NAME, STEP_TYPE_NAME), STEP_TYPE_DESC = COALESCE(:STEP_TYPE_DESC, STEP_TYPE_DESC), RESOURCE_NAME = COALESCE(:RESOURCE_NAME, RESOURCE_NAME), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE), CHANGED_BY_USER_ID = COALESCE(:CHANGED_BY_USER_ID, CHANGED_BY_USER_ID), CHANGED_DATE = COALESCE(:CHANGED_DATE, NOW())\n  WHERE STEP_TYPE_ID = :STEP_TYPE_ID\n\")\n#set($select = \"\n  SELECT STEP_TYPE_ID, STEP_TYPE_NAME, STEP_TYPE_DESC, RESOURCE_NAME, CREATED_BY_USER_ID, CREATED_DATE, CHANGED_BY_USER_ID, CHANGED_DATE\n  FROM STEP_TYPE\n  WHERE STEP_TYPE_ID = :STEP_TYPE_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":STEP_TYPE_ID\": $util.toJson($ctx.args.input.STEP_TYPE_ID),\n    \":STEP_TYPE_NAME\": $util.toJson($util.defaultIfNull($ctx.args.input.STEP_TYPE_NAME, null)),\n    \":STEP_TYPE_DESC\": $util.toJson($util.defaultIfNull($ctx.args.input.STEP_TYPE_DESC, null)),\n    \":RESOURCE_NAME\": $util.toJson($util.defaultIfNull($ctx.args.input.RESOURCE_NAME, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null)),\n    \":CHANGED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_BY_USER_ID, null)),\n    \":CHANGED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CHANGED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for STEP_TYPE_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverMutationupdateSTEPTYPEPARAMMAP": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Mutation",
        "FieldName": "updateSTEP_TYPE_PARAM_MAP",
        "RequestMappingTemplate": "#set($update = \"\n  UPDATE STEP_TYPE_PARAM_MAP\n  SET STEP_TYPE_ID = COALESCE(:STEP_TYPE_ID, STEP_TYPE_ID), SERVICE_PARAM_MAPPING_ID = COALESCE(:SERVICE_PARAM_MAPPING_ID, SERVICE_PARAM_MAPPING_ID), CREATED_BY_USER_ID = COALESCE(:CREATED_BY_USER_ID, CREATED_BY_USER_ID), CREATED_DATE = COALESCE(:CREATED_DATE, CREATED_DATE)\n  WHERE STEP_TYPE_PARAM_MAP_ID = :STEP_TYPE_PARAM_MAP_ID\n\")\n#set($select = \"\n  SELECT STEP_TYPE_PARAM_MAP_ID, STEP_TYPE_ID, SERVICE_PARAM_MAPPING_ID, CREATED_BY_USER_ID, CREATED_DATE\n  FROM STEP_TYPE_PARAM_MAP\n  WHERE STEP_TYPE_PARAM_MAP_ID = :STEP_TYPE_PARAM_MAP_ID\n\")\n{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"$util.escapeJavaScript($update)\",\n    \"$util.escapeJavaScript($select)\"\n  ],\n  \"variableMap\": {\n    \":STEP_TYPE_PARAM_MAP_ID\": $util.toJson($ctx.args.input.STEP_TYPE_PARAM_MAP_ID),\n    \":STEP_TYPE_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.STEP_TYPE_ID, null)),\n    \":SERVICE_PARAM_MAPPING_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.SERVICE_PARAM_MAPPING_ID, null)),\n    \":CREATED_BY_USER_ID\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_BY_USER_ID, null)),\n    \":CREATED_DATE\": $util.toJson($util.defaultIfNull($ctx.args.input.CREATED_DATE, null))\n  }\n}",
        "ResponseMappingTemplate": "#if($ctx.error)\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($rows = $util.rds.toJsonObject($ctx.result))\n#if($rows.size() < 2 || $rows[1].size() == 0)\n  $util.error(\"No row found for STEP_TYPE_PARAM_MAP_ID.\", \"NotFound\")\n#end\n\n$util.toJson($rows[1][0])",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistCONFIGPARAMS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listCONFIG_PARAMS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM CONFIG_PARAM ORDER BY CONFIG_PARAM_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistFILTERCRITERIAS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listFILTER_CRITERIAS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM FILTER_CRITERIA ORDER BY FILTER_CRITERIA_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistLOANAPPS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listLOAN_APPS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM LOAN_APP ORDER BY LOAN_APP_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistNEWMEMBERTOKENS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listNEW_MEMBER_TOKENS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM NEW_MEMBER_TOKEN ORDER BY NEW_MEMBER_TOKEN_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistORIGINPRODUCTS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listORIGIN_PRODUCTS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM ORIGIN_PRODUCT ORDER BY ORIGIN_PRODUCT_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistREDIRECTURLS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listREDIRECT_URLS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM REDIRECT_URL ORDER BY REDIRECT_URL_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSERVICES": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSERVICES",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE ORDER BY SERVICE_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSERVICEDOMAINS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSERVICE_DOMAINS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_DOMAIN ORDER BY SERVICE_DOMAIN_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSERVICEEXPRMAPPINGS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSERVICE_EXPR_MAPPINGS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_EXPR_MAPPING ORDER BY SERVICE_EXPR_MAPPING_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSERVICEPARAMS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSERVICE_PARAMS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_PARAM ORDER BY SERVICE_PARAM_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSERVICEPARAMMAPPINGS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSERVICE_PARAM_MAPPINGS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_PARAM_MAPPING ORDER BY SERVICE_PARAM_MAPPING_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSERVICEPROVIDERS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSERVICE_PROVIDERS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_PROVIDER ORDER BY SERVICE_PROVIDER_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSORTCRITERIAS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSORT_CRITERIAS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SORT_CRITERIA ORDER BY SORT_CRITERIA_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSTEPSERVICEMAPPINGS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSTEP_SERVICE_MAPPINGS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM STEP_SERVICE_MAPPING ORDER BY STEP_SERVICE_MAPPING_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSTEPTYPES": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSTEP_TYPES",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM STEP_TYPE ORDER BY STEP_TYPE_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    },
    "GraphQlResolverQuerylistSTEPTYPEPARAMMAPS": {
      "Type": "AWS::AppSync::Resolver",
      "DependsOn": "GraphQlSchema",
      "Properties": {
        "ApiId": {
          "Fn::GetAtt": [
            "GraphQlApi",
            "ApiId"
          ]
        },
        "TypeName": "Query",
        "FieldName": "listSTEP_TYPE_PARAM_MAPS",
        "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM STEP_TYPE_PARAM_MAP ORDER BY STEP_TYPE_PARAM_MAP_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
        "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
        "Kind": "UNIT",
        "DataSourceName": {
          "Fn::GetAtt": [
            "GraphQlDsStageDataSource",
            "Name"
          ]
        }
      }
    }
  },
  "Outputs": {
    "ServerlessDeploymentBucketName": {
      "Value": "hazel-mapping-serverless-deployment-bucket",
      "Export": {
        "Name": "sls-vue-appsync-api-dev-ServerlessDeploymentBucketName"
      }
    },
    "GraphQlApiKeyDefault": {
      "Value": {
        "Fn::GetAtt": [
          "GraphQlApiKeyDefault",
          "ApiKey"
        ]
      }
    },
    "GraphQlApiId": {
      "Value": {
        "Fn::GetAtt": [
          "GraphQlApi",
          "ApiId"
        ]
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-GraphQlApiId"
        }
      }
    },
    "GraphQlApiUrl": {
      "Value": {
        "Fn::GetAtt": [
          "GraphQlApi",
          "GraphQLUrl"
        ]
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-GraphQlApiUrl"
        }
      }
    }
  }
}