{
  "service": {
    "service": "vue-appsync-api",
    "serviceObject": {
      "name": "vue-appsync-api"
    },
    "provider": {
      "name": "aws",
      "runtime": "nodejs18.x",
      "region": "us-east-2",
      "stage": "dev",
      "deploymentBucket": "hazel-mapping-serverless-deployment-bucket",
      "versionFunctions": true,
      "deploymentBucketObject": {
        "skipPolicySetup": true,
        "name": "hazel-mapping-serverless-deployment-bucket"
      },
      "compiledCloudFormationTemplate": {
        "AWSTemplateFormatVersion": "2010-09-09",
        "Description": "The AWS CloudFormation template for this Serverless application",
        "Resources": {
          "EmailDomainValidationFunction": {
            "Type": "AWS::Lambda::Function",
            "Properties": {
              "FunctionName": "email-domain-validation-dev",
              "Runtime": "nodejs18.x",
              "Handler": "index.handler",
              "Code": {
                "ZipFile": "exports.handler = async (event) => {\n  const email = event.request.userAttributes.email;\n  \n  // Input validation\n  if (!email || typeof email !== 'string') {\n    throw new Error('Invalid email format');\n  }\n  \n  var emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    throw new Error('Invalid email format');\n  }\n  \n  if (!email.endsWith('@velera.com')) {\n    throw new Error('Only @velera.com email addresses are allowed');\n  }\n  \n  console.log('Email validation passed for domain: ' + email.split('@')[1]);\n  return event;\n};\n"
              },
              "Role": {
                "Fn::GetAtt": [
                  "LambdaExecutionRole",
                  "Arn"
                ]
              }
            }
          },
          "PostConfirmationFunction": {
            "Type": "AWS::Lambda::Function",
            "Properties": {
              "FunctionName": "post-confirmation-dev",
              "Runtime": "nodejs18.x",
              "Handler": "index.handler",
              "Code": {
                "ZipFile": "const { CognitoIdentityProviderClient, AdminAddUserToGroupCommand, ListUsersInGroupCommand } = require('@aws-sdk/client-cognito-identity-provider');\nconst { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');\n\nconst cognito = new CognitoIdentityProviderClient({ region: 'us-east-2' });\nconst ses = new SESClient({ region: 'us-east-2' });\n\nexports.handler = async (event) => {\n  const { userPoolId, userName } = event;\n  const userAttributes = event.request.userAttributes;\n  const region = process.env.AWS_REGION;\n  \n  // Input validation\n  if (!userAttributes.email || !userAttributes.email.includes('@')) {\n    console.error('Invalid email format');\n    return event;\n  }\n  \n  try {\n    // Add user to ReadOnly group by default\n    await cognito.send(new AdminAddUserToGroupCommand({\n      GroupName: 'readonly',\n      UserPoolId: userPoolId,\n      Username: userName\n    }));\n    \n    console.log('User ' + userName + ' added to readonly group');\n    \n    // Send notification to admins about new user\n    const adminUsers = await cognito.send(new ListUsersInGroupCommand({\n      GroupName: 'admin',\n      UserPoolId: userPoolId\n    }));\n    \n    const adminEmails = adminUsers.Users.map(user => \n      user.Attributes.find(attr => attr.Name === 'email')?.Value\n    ).filter(email => email && email.includes('@'));\n    \n    console.log('Admin emails found:', JSON.stringify(adminEmails));\n    \n    if (adminEmails.length > 0) {\n      const emailParams = {\n        Source: 'eshubkagel@velera.com',\n        Destination: { ToAddresses: adminEmails },\n        Message: {\n          Subject: { Data: 'New User Registration: ' + userAttributes.email.split('@')[0] + '@*** (' + (userAttributes.name || 'Unknown') + ')' },\n          Body: {\n            Text: {\n              Data: 'New user has registered and been added to readonly group.\\n\\nUser Details:\\n- Email: ' + userAttributes.email + '\\n- Username: ' + userName + '\\n- ' + (userAttributes.name || 'Requested Access: Unknown') + '\\n\\nTo add user to requested group:\\nhttps://us-east-2.console.aws.amazon.com/cognito/v2/idp/user-pools/' + userPoolId + '/user-management/groups/details/' + (userAttributes.name ? userAttributes.name.replace('Requested: ', '').toLowerCase() : 'developer') + '/add-user?region=' + region\n            }\n          }\n        }\n      };\n      \n      console.log('Sending email TO:', JSON.stringify(adminEmails));\n      const result = await ses.send(new SendEmailCommand(emailParams));\n      console.log('SES Response:', JSON.stringify(result));\n      console.log('Notification sent to ' + adminEmails.length + ' admins');\n    }\n  } catch (error) {\n    console.error('Error in post-confirmation:', error.message);\n    console.error('Full error:', JSON.stringify(error));\n  }\n  \n  return event;\n};\n"
              },
              "Role": {
                "Fn::GetAtt": [
                  "PostConfirmationLambdaRole",
                  "Arn"
                ]
              }
            }
          },
          "PostConfirmationLambdaRole": {
            "Type": "AWS::IAM::Role",
            "Properties": {
              "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "lambda.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                  }
                ]
              },
              "ManagedPolicyArns": [
                "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
              ],
              "Policies": [
                {
                  "PolicyName": "CognitoGroupManagement",
                  "PolicyDocument": {
                    "Version": "2012-10-17",
                    "Statement": [
                      {
                        "Effect": "Allow",
                        "Action": [
                          "cognito-idp:AdminAddUserToGroup",
                          "cognito-idp:ListUsersInGroup"
                        ],
                        "Resource": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
                      },
                      {
                        "Effect": "Allow",
                        "Action": [
                          "ses:SendEmail"
                        ],
                        "Resource": [
                          "arn:aws:ses:us-east-2:*:identity/eshubkagel@velera.com"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "PostConfirmationLambdaPermission": {
            "Type": "AWS::Lambda::Permission",
            "Properties": {
              "FunctionName": {
                "Ref": "PostConfirmationFunction"
              },
              "Action": "lambda:InvokeFunction",
              "Principal": "cognito-idp.amazonaws.com",
              "SourceArn": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
            }
          },
          "LambdaExecutionRole": {
            "Type": "AWS::IAM::Role",
            "Properties": {
              "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "lambda.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                  }
                ]
              },
              "ManagedPolicyArns": [
                "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
              ]
            }
          },
          "CognitoLambdaPermission": {
            "Type": "AWS::Lambda::Permission",
            "Properties": {
              "FunctionName": {
                "Ref": "EmailDomainValidationFunction"
              },
              "Action": "lambda:InvokeFunction",
              "Principal": "cognito-idp.amazonaws.com",
              "SourceArn": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
            }
          },
          "AppSyncLoggingRole": {
            "Type": "AWS::IAM::Role",
            "Properties": {
              "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "appsync.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                  }
                ]
              },
              "Policies": [
                {
                  "PolicyName": "CloudWatchLogsAccess",
                  "PolicyDocument": {
                    "Version": "2012-10-17",
                    "Statement": [
                      {
                        "Effect": "Allow",
                        "Action": [
                          "logs:CreateLogGroup",
                          "logs:CreateLogStream",
                          "logs:PutLogEvents"
                        ],
                        "Resource": "*"
                      }
                    ]
                  }
                }
              ]
            }
          },
          "RDSServiceRole": {
            "Type": "AWS::IAM::Role",
            "Properties": {
              "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "appsync.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                  }
                ]
              },
              "Policies": [
                {
                  "PolicyName": "RDSDataAccess",
                  "PolicyDocument": {
                    "Version": "2012-10-17",
                    "Statement": [
                      {
                        "Effect": "Allow",
                        "Action": [
                          "rds-data:*"
                        ],
                        "Resource": [
                          "arn:aws:rds:us-east-2:*:cluster:hazel-mapping"
                        ]
                      },
                      {
                        "Effect": "Allow",
                        "Action": [
                          "secretsmanager:GetSecretValue",
                          "kms:Decrypt",
                          "kms:DescribeKey"
                        ],
                        "Resource": [
                          "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-a11d98c5-d647-45a2-9978-f81be7aa3d60-iDsvX3",
                          "arn:aws:kms:us-east-2:*:key/*"
                        ]
                      },
                      {
                        "Effect": "Allow",
                        "Action": [
                          "logs:CreateLogGroup",
                          "logs:CreateLogStream",
                          "logs:PutLogEvents"
                        ],
                        "Resource": [
                          "arn:aws:logs:us-east-2:*:log-group:/aws/appsync/*"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "GraphQlApi": {
            "Type": "AWS::AppSync::GraphQLApi",
            "Properties": {
              "Name": "vue-appsync-api-dev",
              "AuthenticationType": "AMAZON_COGNITO_USER_POOLS",
              "AdditionalAuthenticationProviders": [
                {
                  "AuthenticationType": "API_KEY"
                }
              ],
              "UserPoolConfig": {
                "AwsRegion": "us-east-2",
                "UserPoolId": "us-east-2_iAtP0Uzh5",
                "DefaultAction": "ALLOW"
              },
              "XrayEnabled": false
            }
          },
          "GraphQlApiKeyDefault": {
            "Type": "AWS::AppSync::ApiKey",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "Description": "Auto-generated api key",
              "Expires": 1791493200
            }
          },
          "GraphQlSchema": {
            "Type": "AWS::AppSync::GraphQLSchema",
            "Properties": {
              "Definition": "schema {\n  query: Query\n  mutation: Mutation\n  subscription: Subscription\n}\n\ntype CONFIG_PARAM {\n  CONFIG_PARAM_ID: Int\n  CONFIG_NAME: String!\n  CONFIG_VALUE: String!\n  DESCRIPTION: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ntype FILTER_CRITERIA {\n  FILTER_CRITERIA_ID: Int\n  ORIGIN_PRODUCT_ID: Int!\n  STEP_TYPE_ID: Int!\n  CRITERIA: String!\n  SEQUENCE_NBR: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ntype LOAN_APP {\n  LOAN_APP_ID: Int\n  ORIGIN_LOAN_APP_ID: String!\n  ORIGIN_PRODUCT_ID: Int!\n  PROCESS_FLAG: String!\n  EXEC_ID: String\n  CREATED_DATE: String!\n  CHANGED_DATE: String\n}\n\ntype LOAN_APP_EXECS {\n  LOAN_APP_EXEC_ID: Int\n  LOAN_APP_ID: Int!\n  AWS_EXEC_ID: String!\n  CREATED_DATE: String!\n}\n\ntype LOAN_APP_STEP_STATUS {\n  LOAN_APP_STEP_STATUS_ID: Int\n  LOAN_APP_ID: Int!\n  LOAN_APP_EXEC_ID: Int\n  STEP_TYPE_ID: Int!\n  COMPLETE_FLAG: String!\n  SEQUENCE_NBR: Int!\n  IDX_JSON_PATH: String\n  RESPONSE_TEXT: String\n  OUTPUT_JSON: String\n  CREATED_DATE: String\n}\n\ntype NEW_MEMBER_TOKEN {\n  NEW_MEMBER_TOKEN_ID: Int\n  MEMBER_NBR: String\n  CARD_NBR: String\n  PERSON_NBR: String\n  LOAN_APP_ID: Int!\n  FIRST_NAME: String\n  LAST_NAME: String\n  DOB: String\n  TAX_ID: String\n  EMAIL_ADDRESS_TEXT: String\n  ZIP_CODE: String\n  HOME_PHONE_NBR: String\n  MOBILE_PHONE_NBR: String\n  TOKEN_VALUE: String\n  TOKEN_USED_FLAG: String!\n  CREATED_DATE: String!\n  CHANGED_DATE: String\n}\n\ntype ORIGIN_PRODUCT {\n  ORIGIN_PRODUCT_ID: Int\n  VENDOR_NAME: String!\n  PRODUCT_ID: String!\n  PSCU_CLIENT_ID: Int!\n  PRODUCT_DESC: String!\n  PARTNER_CODE: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype REDIRECT_URL {\n  REDIRECT_URL_ID: Int\n  ORIGIN_PRODUCT_ID: Int!\n  URL_TYPE_CODE: String!\n  URL: String!\n  RESPONSE_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE {\n  SERVICE_ID: Int\n  SERVICE_PROVIDER_ID: Int!\n  URI: String!\n  SECRET_NAME: String\n  REQUEST_TYPE: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE_DOMAIN {\n  SERVICE_DOMAIN_ID: Int\n  DOMAIN_URL: String\n  SERVICE_PROVIDER_ID: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ntype SERVICE_EXPR_MAPPING {\n  SERVICE_EXPR_MAPPING_ID: Int\n  SERVICE_PARAM_MAPPING_ID: Int!\n  SOURCE_EXPR: String\n  TARGET_EXPR: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE_PARAM {\n  SERVICE_PARAM_ID: Int\n  SERVICE_ID: Int!\n  PARAM_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE_PARAM_MAPPING {\n  SERVICE_PARAM_MAPPING_ID: Int\n  ORIGIN_PRODUCT_ID: Int!\n  SYSTEM_NBR: String\n  PRIN_NBR: String\n  AGENT_NBR: String\n  SOURCE_SERVICE_PARAM_ID: Int!\n  TARGET_SERVICE_PARAM_ID: Int!\n  PLASTIC_TYPE_ID: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SERVICE_PROVIDER {\n  SERVICE_PROVIDER_ID: Int\n  SERVICE_PROVIDER_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype SORT_CRITERIA {\n  SORT_CRITERIA_ID: Int\n  ORIGIN_PRODUCT_ID: Int!\n  STEP_TYPE_ID: Int!\n  JSON_PATH: String!\n  SORT_ORDER: String!\n  SORT_PRIORITY: Int!\n  SEQUENCE_NBR: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ntype STEP_SERVICE_MAPPING {\n  STEP_SERVICE_MAPPING_ID: Int\n  STEP_TYPE_ID: Int!\n  SERVICE_ID: Int!\n  SEQUENCE_NBR: Int\n}\n\ntype STEP_TYPE {\n  STEP_TYPE_ID: Int\n  STEP_TYPE_NAME: String!\n  STEP_TYPE_DESC: String\n  RESOURCE_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ntype STEP_TYPE_PARAM_MAP {\n  STEP_TYPE_PARAM_MAP_ID: Int\n  STEP_TYPE_ID: Int\n  SERVICE_PARAM_MAPPING_ID: Int!\n  CREATED_BY_USER_ID: String\n  CREATED_DATE: String\n}\n\ninput CreateCONFIG_PARAMInput {\n  CONFIG_NAME: String!\n  CONFIG_VALUE: String!\n  DESCRIPTION: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput UpdateCONFIG_PARAMInput {\n  CONFIG_PARAM_ID: Int!\n  CONFIG_NAME: String\n  CONFIG_VALUE: String\n  DESCRIPTION: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteCONFIG_PARAMInput {\n  CONFIG_PARAM_ID: Int!\n}\n\ninput CreateFILTER_CRITERIAInput {\n  ORIGIN_PRODUCT_ID: Int!\n  STEP_TYPE_ID: Int!\n  CRITERIA: String!\n  SEQUENCE_NBR: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput UpdateFILTER_CRITERIAInput {\n  FILTER_CRITERIA_ID: Int!\n  ORIGIN_PRODUCT_ID: Int\n  STEP_TYPE_ID: Int\n  CRITERIA: String\n  SEQUENCE_NBR: Int\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteFILTER_CRITERIAInput {\n  FILTER_CRITERIA_ID: Int!\n}\n\ninput CreateLOAN_APPInput {\n  ORIGIN_LOAN_APP_ID: String!\n  ORIGIN_PRODUCT_ID: Int!\n  PROCESS_FLAG: String!\n  EXEC_ID: String\n  CREATED_DATE: String!\n  CHANGED_DATE: String\n}\n\ninput UpdateLOAN_APPInput {\n  LOAN_APP_ID: Int!\n  ORIGIN_LOAN_APP_ID: String\n  ORIGIN_PRODUCT_ID: Int\n  PROCESS_FLAG: String\n  EXEC_ID: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteLOAN_APPInput {\n  LOAN_APP_ID: Int!\n}\n\ninput CreateLOAN_APP_EXECSInput {\n  LOAN_APP_ID: Int!\n  AWS_EXEC_ID: String!\n  CREATED_DATE: String!\n}\n\ninput UpdateLOAN_APP_EXECSInput {\n  LOAN_APP_EXEC_ID: Int!\n  LOAN_APP_ID: Int\n  AWS_EXEC_ID: String\n  CREATED_DATE: String\n}\n\ninput DeleteLOAN_APP_EXECSInput {\n  LOAN_APP_EXEC_ID: Int!\n}\n\ninput CreateLOAN_APP_STEP_STATUSInput {\n  LOAN_APP_ID: Int!\n  LOAN_APP_EXEC_ID: Int\n  STEP_TYPE_ID: Int!\n  COMPLETE_FLAG: String!\n  SEQUENCE_NBR: Int!\n  IDX_JSON_PATH: String\n  RESPONSE_TEXT: String\n  OUTPUT_JSON: String\n  CREATED_DATE: String\n}\n\ninput UpdateLOAN_APP_STEP_STATUSInput {\n  LOAN_APP_STEP_STATUS_ID: Int!\n  LOAN_APP_ID: Int\n  LOAN_APP_EXEC_ID: Int\n  STEP_TYPE_ID: Int\n  COMPLETE_FLAG: String\n  SEQUENCE_NBR: Int\n  IDX_JSON_PATH: String\n  RESPONSE_TEXT: String\n  OUTPUT_JSON: String\n  CREATED_DATE: String\n}\n\ninput DeleteLOAN_APP_STEP_STATUSInput {\n  LOAN_APP_STEP_STATUS_ID: Int!\n}\n\ninput CreateNEW_MEMBER_TOKENInput {\n  MEMBER_NBR: String\n  CARD_NBR: String\n  PERSON_NBR: String\n  LOAN_APP_ID: Int!\n  FIRST_NAME: String\n  LAST_NAME: String\n  DOB: String\n  TAX_ID: String\n  EMAIL_ADDRESS_TEXT: String\n  ZIP_CODE: String\n  HOME_PHONE_NBR: String\n  MOBILE_PHONE_NBR: String\n  TOKEN_VALUE: String\n  TOKEN_USED_FLAG: String!\n  CREATED_DATE: String!\n  CHANGED_DATE: String\n}\n\ninput UpdateNEW_MEMBER_TOKENInput {\n  NEW_MEMBER_TOKEN_ID: Int!\n  MEMBER_NBR: String\n  CARD_NBR: String\n  PERSON_NBR: String\n  LOAN_APP_ID: Int\n  FIRST_NAME: String\n  LAST_NAME: String\n  DOB: String\n  TAX_ID: String\n  EMAIL_ADDRESS_TEXT: String\n  ZIP_CODE: String\n  HOME_PHONE_NBR: String\n  MOBILE_PHONE_NBR: String\n  TOKEN_VALUE: String\n  TOKEN_USED_FLAG: String\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteNEW_MEMBER_TOKENInput {\n  NEW_MEMBER_TOKEN_ID: Int!\n}\n\ninput CreateORIGIN_PRODUCTInput {\n  VENDOR_NAME: String!\n  PRODUCT_ID: String!\n  PSCU_CLIENT_ID: Int!\n  PRODUCT_DESC: String!\n  PARTNER_CODE: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateORIGIN_PRODUCTInput {\n  ORIGIN_PRODUCT_ID: Int!\n  VENDOR_NAME: String\n  PRODUCT_ID: String\n  PSCU_CLIENT_ID: Int\n  PRODUCT_DESC: String\n  PARTNER_CODE: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteORIGIN_PRODUCTInput {\n  ORIGIN_PRODUCT_ID: Int!\n}\n\ninput CreateREDIRECT_URLInput {\n  ORIGIN_PRODUCT_ID: Int!\n  URL_TYPE_CODE: String!\n  URL: String!\n  RESPONSE_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateREDIRECT_URLInput {\n  REDIRECT_URL_ID: Int!\n  ORIGIN_PRODUCT_ID: Int\n  URL_TYPE_CODE: String\n  URL: String\n  RESPONSE_TEXT: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteREDIRECT_URLInput {\n  REDIRECT_URL_ID: Int!\n}\n\ninput CreateSERVICEInput {\n  SERVICE_PROVIDER_ID: Int!\n  URI: String!\n  SECRET_NAME: String\n  REQUEST_TYPE: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICEInput {\n  SERVICE_ID: Int!\n  SERVICE_PROVIDER_ID: Int\n  URI: String\n  SECRET_NAME: String\n  REQUEST_TYPE: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICEInput {\n  SERVICE_ID: Int!\n}\n\ninput CreateSERVICE_DOMAINInput {\n  DOMAIN_URL: String\n  SERVICE_PROVIDER_ID: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_DOMAINInput {\n  SERVICE_DOMAIN_ID: Int!\n  DOMAIN_URL: String\n  SERVICE_PROVIDER_ID: Int\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_DOMAINInput {\n  SERVICE_DOMAIN_ID: Int!\n}\n\ninput CreateSERVICE_EXPR_MAPPINGInput {\n  SERVICE_PARAM_MAPPING_ID: Int!\n  SOURCE_EXPR: String\n  TARGET_EXPR: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_EXPR_MAPPINGInput {\n  SERVICE_EXPR_MAPPING_ID: Int!\n  SERVICE_PARAM_MAPPING_ID: Int\n  SOURCE_EXPR: String\n  TARGET_EXPR: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_EXPR_MAPPINGInput {\n  SERVICE_EXPR_MAPPING_ID: Int!\n}\n\ninput CreateSERVICE_PARAMInput {\n  SERVICE_ID: Int!\n  PARAM_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_PARAMInput {\n  SERVICE_PARAM_ID: Int!\n  SERVICE_ID: Int\n  PARAM_NAME: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_PARAMInput {\n  SERVICE_PARAM_ID: Int!\n}\n\ninput CreateSERVICE_PARAM_MAPPINGInput {\n  ORIGIN_PRODUCT_ID: Int!\n  SYSTEM_NBR: String\n  PRIN_NBR: String\n  AGENT_NBR: String\n  SOURCE_SERVICE_PARAM_ID: Int!\n  TARGET_SERVICE_PARAM_ID: Int!\n  PLASTIC_TYPE_ID: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_PARAM_MAPPINGInput {\n  SERVICE_PARAM_MAPPING_ID: Int!\n  ORIGIN_PRODUCT_ID: Int\n  SYSTEM_NBR: String\n  PRIN_NBR: String\n  AGENT_NBR: String\n  SOURCE_SERVICE_PARAM_ID: Int\n  TARGET_SERVICE_PARAM_ID: Int\n  PLASTIC_TYPE_ID: String\n  COMMENT_TEXT: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_PARAM_MAPPINGInput {\n  SERVICE_PARAM_MAPPING_ID: Int!\n}\n\ninput CreateSERVICE_PROVIDERInput {\n  SERVICE_PROVIDER_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSERVICE_PROVIDERInput {\n  SERVICE_PROVIDER_ID: Int!\n  SERVICE_PROVIDER_NAME: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSERVICE_PROVIDERInput {\n  SERVICE_PROVIDER_ID: Int!\n}\n\ninput CreateSORT_CRITERIAInput {\n  ORIGIN_PRODUCT_ID: Int!\n  STEP_TYPE_ID: Int!\n  JSON_PATH: String!\n  SORT_ORDER: String!\n  SORT_PRIORITY: Int!\n  SEQUENCE_NBR: Int!\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput UpdateSORT_CRITERIAInput {\n  SORT_CRITERIA_ID: Int!\n  ORIGIN_PRODUCT_ID: Int\n  STEP_TYPE_ID: Int\n  JSON_PATH: String\n  SORT_ORDER: String\n  SORT_PRIORITY: Int\n  SEQUENCE_NBR: Int\n  CREATED_DATE: String\n  CHANGED_DATE: String\n}\n\ninput DeleteSORT_CRITERIAInput {\n  SORT_CRITERIA_ID: Int!\n}\n\ninput CreateSTEP_SERVICE_MAPPINGInput {\n  STEP_TYPE_ID: Int!\n  SERVICE_ID: Int!\n  SEQUENCE_NBR: Int\n}\n\ninput UpdateSTEP_SERVICE_MAPPINGInput {\n  STEP_SERVICE_MAPPING_ID: Int!\n  STEP_TYPE_ID: Int\n  SERVICE_ID: Int\n  SEQUENCE_NBR: Int\n}\n\ninput DeleteSTEP_SERVICE_MAPPINGInput {\n  STEP_SERVICE_MAPPING_ID: Int!\n}\n\ninput CreateSTEP_TYPEInput {\n  STEP_TYPE_NAME: String!\n  STEP_TYPE_DESC: String\n  RESOURCE_NAME: String!\n  CREATED_BY_USER_ID: Int!\n  CREATED_DATE: String!\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput UpdateSTEP_TYPEInput {\n  STEP_TYPE_ID: Int!\n  STEP_TYPE_NAME: String\n  STEP_TYPE_DESC: String\n  RESOURCE_NAME: String\n  CREATED_BY_USER_ID: Int\n  CREATED_DATE: String\n  CHANGED_BY_USER_ID: Int\n  CHANGED_DATE: String\n}\n\ninput DeleteSTEP_TYPEInput {\n  STEP_TYPE_ID: Int!\n}\n\ninput CreateSTEP_TYPE_PARAM_MAPInput {\n  STEP_TYPE_ID: Int\n  SERVICE_PARAM_MAPPING_ID: Int!\n  CREATED_BY_USER_ID: String\n  CREATED_DATE: String\n}\n\ninput UpdateSTEP_TYPE_PARAM_MAPInput {\n  STEP_TYPE_PARAM_MAP_ID: Int!\n  STEP_TYPE_ID: Int\n  SERVICE_PARAM_MAPPING_ID: Int\n  CREATED_BY_USER_ID: String\n  CREATED_DATE: String\n}\n\ninput DeleteSTEP_TYPE_PARAM_MAPInput {\n  STEP_TYPE_PARAM_MAP_ID: Int!\n}\n\ntype CONFIG_PARAMConnection {\n  items: [CONFIG_PARAM]\n  nextToken: String\n}\n\ntype FILTER_CRITERIAConnection {\n  items: [FILTER_CRITERIA]\n  nextToken: String\n}\n\ntype LOAN_APPConnection {\n  items: [LOAN_APP]\n  nextToken: String\n}\n\ntype LOAN_APP_EXECSConnection {\n  items: [LOAN_APP_EXECS]\n  nextToken: String\n}\n\ntype LOAN_APP_STEP_STATUSConnection {\n  items: [LOAN_APP_STEP_STATUS]\n  nextToken: String\n}\n\ntype NEW_MEMBER_TOKENConnection {\n  items: [NEW_MEMBER_TOKEN]\n  nextToken: String\n}\n\ntype ORIGIN_PRODUCTConnection {\n  items: [ORIGIN_PRODUCT]\n  nextToken: String\n}\n\ntype REDIRECT_URLConnection {\n  items: [REDIRECT_URL]\n  nextToken: String\n}\n\ntype SERVICEConnection {\n  items: [SERVICE]\n  nextToken: String\n}\n\ntype SERVICE_DOMAINConnection {\n  items: [SERVICE_DOMAIN]\n  nextToken: String\n}\n\ntype SERVICE_EXPR_MAPPINGConnection {\n  items: [SERVICE_EXPR_MAPPING]\n  nextToken: String\n}\n\ntype SERVICE_PARAMConnection {\n  items: [SERVICE_PARAM]\n  nextToken: String\n}\n\ntype SERVICE_PARAM_MAPPINGConnection {\n  items: [SERVICE_PARAM_MAPPING]\n  nextToken: String\n}\n\ntype SERVICE_PROVIDERConnection {\n  items: [SERVICE_PROVIDER]\n  nextToken: String\n}\n\ntype SORT_CRITERIAConnection {\n  items: [SORT_CRITERIA]\n  nextToken: String\n}\n\ntype STEP_SERVICE_MAPPINGConnection {\n  items: [STEP_SERVICE_MAPPING]\n  nextToken: String\n}\n\ntype STEP_TYPEConnection {\n  items: [STEP_TYPE]\n  nextToken: String\n}\n\ntype STEP_TYPE_PARAM_MAPConnection {\n  items: [STEP_TYPE_PARAM_MAP]\n  nextToken: String\n}\n\ntype Query {\n  listCONFIG_PARAMS: CONFIG_PARAMConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listFILTER_CRITERIAS: FILTER_CRITERIAConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listLOAN_APPS: LOAN_APPConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listLOAN_APP_EXECSS: LOAN_APP_EXECSConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listLOAN_APP_STEP_STATUSS: LOAN_APP_STEP_STATUSConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listNEW_MEMBER_TOKENS: NEW_MEMBER_TOKENConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listORIGIN_PRODUCTS: ORIGIN_PRODUCTConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listREDIRECT_URLS: REDIRECT_URLConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICES: SERVICEConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_DOMAINS: SERVICE_DOMAINConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_EXPR_MAPPINGS: SERVICE_EXPR_MAPPINGConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_PARAMS: SERVICE_PARAMConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_PARAM_MAPPINGS: SERVICE_PARAM_MAPPINGConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSERVICE_PROVIDERS: SERVICE_PROVIDERConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSORT_CRITERIAS: SORT_CRITERIAConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSTEP_SERVICE_MAPPINGS: STEP_SERVICE_MAPPINGConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSTEP_TYPES: STEP_TYPEConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n  listSTEP_TYPE_PARAM_MAPS: STEP_TYPE_PARAM_MAPConnection @aws_auth(cognito_groups: [\"readonly\", \"developer\", \"deployment\", \"admin\"])\n}\n\ntype Mutation {\n  createCONFIG_PARAM(input: CreateCONFIG_PARAMInput!): CONFIG_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateCONFIG_PARAM(input: UpdateCONFIG_PARAMInput!): CONFIG_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteCONFIG_PARAM(input: DeleteCONFIG_PARAMInput!): CONFIG_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createFILTER_CRITERIA(input: CreateFILTER_CRITERIAInput!): FILTER_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateFILTER_CRITERIA(input: UpdateFILTER_CRITERIAInput!): FILTER_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteFILTER_CRITERIA(input: DeleteFILTER_CRITERIAInput!): FILTER_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createORIGIN_PRODUCT(input: CreateORIGIN_PRODUCTInput!): ORIGIN_PRODUCT @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateORIGIN_PRODUCT(input: UpdateORIGIN_PRODUCTInput!): ORIGIN_PRODUCT @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteORIGIN_PRODUCT(input: DeleteORIGIN_PRODUCTInput!): ORIGIN_PRODUCT @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createREDIRECT_URL(input: CreateREDIRECT_URLInput!): REDIRECT_URL @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateREDIRECT_URL(input: UpdateREDIRECT_URLInput!): REDIRECT_URL @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteREDIRECT_URL(input: DeleteREDIRECT_URLInput!): REDIRECT_URL @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE(input: CreateSERVICEInput!): SERVICE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE(input: UpdateSERVICEInput!): SERVICE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE(input: DeleteSERVICEInput!): SERVICE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_DOMAIN(input: CreateSERVICE_DOMAINInput!): SERVICE_DOMAIN @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_DOMAIN(input: UpdateSERVICE_DOMAINInput!): SERVICE_DOMAIN @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_DOMAIN(input: DeleteSERVICE_DOMAINInput!): SERVICE_DOMAIN @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_EXPR_MAPPING(input: CreateSERVICE_EXPR_MAPPINGInput!): SERVICE_EXPR_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_EXPR_MAPPING(input: UpdateSERVICE_EXPR_MAPPINGInput!): SERVICE_EXPR_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_EXPR_MAPPING(input: DeleteSERVICE_EXPR_MAPPINGInput!): SERVICE_EXPR_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_PARAM(input: CreateSERVICE_PARAMInput!): SERVICE_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_PARAM(input: UpdateSERVICE_PARAMInput!): SERVICE_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_PARAM(input: DeleteSERVICE_PARAMInput!): SERVICE_PARAM @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_PARAM_MAPPING(input: CreateSERVICE_PARAM_MAPPINGInput!): SERVICE_PARAM_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_PARAM_MAPPING(input: UpdateSERVICE_PARAM_MAPPINGInput!): SERVICE_PARAM_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_PARAM_MAPPING(input: DeleteSERVICE_PARAM_MAPPINGInput!): SERVICE_PARAM_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSERVICE_PROVIDER(input: CreateSERVICE_PROVIDERInput!): SERVICE_PROVIDER @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSERVICE_PROVIDER(input: UpdateSERVICE_PROVIDERInput!): SERVICE_PROVIDER @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSERVICE_PROVIDER(input: DeleteSERVICE_PROVIDERInput!): SERVICE_PROVIDER @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSORT_CRITERIA(input: CreateSORT_CRITERIAInput!): SORT_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSORT_CRITERIA(input: UpdateSORT_CRITERIAInput!): SORT_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSORT_CRITERIA(input: DeleteSORT_CRITERIAInput!): SORT_CRITERIA @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSTEP_SERVICE_MAPPING(input: CreateSTEP_SERVICE_MAPPINGInput!): STEP_SERVICE_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSTEP_SERVICE_MAPPING(input: UpdateSTEP_SERVICE_MAPPINGInput!): STEP_SERVICE_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSTEP_SERVICE_MAPPING(input: DeleteSTEP_SERVICE_MAPPINGInput!): STEP_SERVICE_MAPPING @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSTEP_TYPE(input: CreateSTEP_TYPEInput!): STEP_TYPE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSTEP_TYPE(input: UpdateSTEP_TYPEInput!): STEP_TYPE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSTEP_TYPE(input: DeleteSTEP_TYPEInput!): STEP_TYPE @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  createSTEP_TYPE_PARAM_MAP(input: CreateSTEP_TYPE_PARAM_MAPInput!): STEP_TYPE_PARAM_MAP @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  updateSTEP_TYPE_PARAM_MAP(input: UpdateSTEP_TYPE_PARAM_MAPInput!): STEP_TYPE_PARAM_MAP @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n  deleteSTEP_TYPE_PARAM_MAP(input: DeleteSTEP_TYPE_PARAM_MAPInput!): STEP_TYPE_PARAM_MAP @aws_auth(cognito_groups: [\"developer\", \"deployment\", \"admin\"])\n}\n\ntype Subscription {\n  onCreateCONFIG_PARAM: CONFIG_PARAM\n  onCreateLOAN_APP: LOAN_APP\n  onCreateNEW_MEMBER_TOKEN: NEW_MEMBER_TOKEN\n  onCreateORIGIN_PRODUCT: ORIGIN_PRODUCT\n}",
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              }
            }
          },
          "GraphQlDsStageDataSource": {
            "Type": "AWS::AppSync::DataSource",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "Name": "StageDataSource",
              "Type": "RELATIONAL_DATABASE",
              "ServiceRoleArn": {
                "Fn::GetAtt": [
                  "RDSServiceRole",
                  "Arn"
                ]
              },
              "RelationalDatabaseConfig": {
                "RdsHttpEndpointConfig": {
                  "AwsRegion": "us-east-2",
                  "DbClusterIdentifier": {
                    "Fn::Join": [
                      ":",
                      [
                        "arn",
                        "aws",
                        "rds",
                        "us-east-2",
                        {
                          "Ref": "AWS::AccountId"
                        },
                        "cluster",
                        "hazel-mapping"
                      ]
                    ]
                  },
                  "DatabaseName": "hazel_mapping_dev",
                  "AwsSecretStoreArn": "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-a11d98c5-d647-45a2-9978-f81be7aa3d60-iDsvX3"
                },
                "RelationalDatabaseSourceType": "RDS_HTTP_ENDPOINT"
              }
            }
          },
          "GraphQlResolverMutationcreateCONFIGPARAM": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createCONFIG_PARAM",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO CONFIG_PARAM (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateFILTERCRITERIA": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createFILTER_CRITERIA",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO FILTER_CRITERIA (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateORIGINPRODUCT": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createORIGIN_PRODUCT",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO ORIGIN_PRODUCT (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateREDIRECTURL": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createREDIRECT_URL",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO REDIRECT_URL (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSERVICE": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSERVICE",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO SERVICE (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSERVICEDOMAIN": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSERVICE_DOMAIN",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO SERVICE_DOMAIN (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSERVICEEXPRMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSERVICE_EXPR_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO SERVICE_EXPR_MAPPING (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSERVICEPARAM": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSERVICE_PARAM",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO SERVICE_PARAM (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSERVICEPARAMMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSERVICE_PARAM_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO SERVICE_PARAM_MAPPING (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSERVICEPROVIDER": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSERVICE_PROVIDER",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO SERVICE_PROVIDER (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSORTCRITERIA": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSORT_CRITERIA",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO SORT_CRITERIA (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSTEPSERVICEMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSTEP_SERVICE_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO STEP_SERVICE_MAPPING (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSTEPTYPE": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSTEP_TYPE",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO STEP_TYPE (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationcreateSTEPTYPEPARAMMAP": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "createSTEP_TYPE_PARAM_MAP",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($insertStatement = \"INSERT INTO STEP_TYPE_PARAM_MAP (\")\n    #set($valuesStatement = \" VALUES (\")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.value)\n        #if(!$first)\n          #set($insertStatement = \"$insertStatement, \")\n          #set($valuesStatement = \"$valuesStatement, \")\n        #end\n        #set($insertStatement = \"$insertStatement$entry.key\")\n        #set($valuesStatement = \"$valuesStatement'$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($insertStatement = \"$insertStatement)$valuesStatement)\")\n    \"$insertStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteCONFIGPARAM": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteCONFIG_PARAM",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM CONFIG_PARAM WHERE CONFIG_PARAM_ID = '$ctx.args.input.CONFIG_PARAM_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteFILTERCRITERIA": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteFILTER_CRITERIA",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM FILTER_CRITERIA WHERE FILTER_CRITERIA_ID = '$ctx.args.input.FILTER_CRITERIA_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteORIGINPRODUCT": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteORIGIN_PRODUCT",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM ORIGIN_PRODUCT WHERE ORIGIN_PRODUCT_ID = '$ctx.args.input.ORIGIN_PRODUCT_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteREDIRECTURL": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteREDIRECT_URL",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM REDIRECT_URL WHERE REDIRECT_URL_ID = '$ctx.args.input.REDIRECT_URL_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSERVICE": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSERVICE",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM SERVICE WHERE SERVICE_ID = '$ctx.args.input.SERVICE_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSERVICEDOMAIN": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSERVICE_DOMAIN",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM SERVICE_DOMAIN WHERE SERVICE_DOMAIN_ID = '$ctx.args.input.SERVICE_DOMAIN_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSERVICEEXPRMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSERVICE_EXPR_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM SERVICE_EXPR_MAPPING WHERE SERVICE_EXPR_MAPPING_ID = '$ctx.args.input.SERVICE_EXPR_MAPPING_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSERVICEPARAM": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSERVICE_PARAM",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM SERVICE_PARAM WHERE SERVICE_PARAM_ID = '$ctx.args.input.SERVICE_PARAM_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSERVICEPARAMMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSERVICE_PARAM_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM SERVICE_PARAM_MAPPING WHERE SERVICE_PARAM_MAPPING_ID = '$ctx.args.input.SERVICE_PARAM_MAPPING_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSERVICEPROVIDER": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSERVICE_PROVIDER",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM SERVICE_PROVIDER WHERE SERVICE_PROVIDER_ID = '$ctx.args.input.SERVICE_PROVIDER_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSORTCRITERIA": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSORT_CRITERIA",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM SORT_CRITERIA WHERE SORT_CRITERIA_ID = '$ctx.args.input.SORT_CRITERIA_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSTEPSERVICEMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSTEP_SERVICE_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM STEP_SERVICE_MAPPING WHERE STEP_SERVICE_MAPPING_ID = '$ctx.args.input.STEP_SERVICE_MAPPING_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSTEPTYPE": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSTEP_TYPE",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM STEP_TYPE WHERE STEP_TYPE_ID = '$ctx.args.input.STEP_TYPE_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationdeleteSTEPTYPEPARAMMAP": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "deleteSTEP_TYPE_PARAM_MAP",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"DELETE FROM STEP_TYPE_PARAM_MAP WHERE STEP_TYPE_PARAM_MAP_ID = '$ctx.args.input.STEP_TYPE_PARAM_MAP_ID'\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateCONFIGPARAM": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateCONFIG_PARAM",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE CONFIG_PARAM SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"CONFIG_PARAM_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE CONFIG_PARAM_ID = '$ctx.args.input.CONFIG_PARAM_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateFILTERCRITERIA": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateFILTER_CRITERIA",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE FILTER_CRITERIA SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"FILTER_CRITERIA_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE FILTER_CRITERIA_ID = '$ctx.args.input.FILTER_CRITERIA_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateORIGINPRODUCT": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateORIGIN_PRODUCT",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE ORIGIN_PRODUCT SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"ORIGIN_PRODUCT_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE ORIGIN_PRODUCT_ID = '$ctx.args.input.ORIGIN_PRODUCT_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateREDIRECTURL": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateREDIRECT_URL",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE REDIRECT_URL SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"REDIRECT_URL_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE REDIRECT_URL_ID = '$ctx.args.input.REDIRECT_URL_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSERVICE": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSERVICE",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE SERVICE SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"SERVICE_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE SERVICE_ID = '$ctx.args.input.SERVICE_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSERVICEDOMAIN": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSERVICE_DOMAIN",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE SERVICE_DOMAIN SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"SERVICE_DOMAIN_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE SERVICE_DOMAIN_ID = '$ctx.args.input.SERVICE_DOMAIN_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSERVICEEXPRMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSERVICE_EXPR_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE SERVICE_EXPR_MAPPING SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"SERVICE_EXPR_MAPPING_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE SERVICE_EXPR_MAPPING_ID = '$ctx.args.input.SERVICE_EXPR_MAPPING_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSERVICEPARAM": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSERVICE_PARAM",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE SERVICE_PARAM SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"SERVICE_PARAM_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE SERVICE_PARAM_ID = '$ctx.args.input.SERVICE_PARAM_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSERVICEPARAMMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSERVICE_PARAM_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE SERVICE_PARAM_MAPPING SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"SERVICE_PARAM_MAPPING_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE SERVICE_PARAM_MAPPING_ID = '$ctx.args.input.SERVICE_PARAM_MAPPING_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSERVICEPROVIDER": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSERVICE_PROVIDER",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE SERVICE_PROVIDER SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"SERVICE_PROVIDER_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE SERVICE_PROVIDER_ID = '$ctx.args.input.SERVICE_PROVIDER_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSORTCRITERIA": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSORT_CRITERIA",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE SORT_CRITERIA SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"SORT_CRITERIA_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE SORT_CRITERIA_ID = '$ctx.args.input.SORT_CRITERIA_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSTEPSERVICEMAPPING": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSTEP_SERVICE_MAPPING",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE STEP_SERVICE_MAPPING SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"STEP_SERVICE_MAPPING_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE STEP_SERVICE_MAPPING_ID = '$ctx.args.input.STEP_SERVICE_MAPPING_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSTEPTYPE": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSTEP_TYPE",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE STEP_TYPE SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"STEP_TYPE_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE STEP_TYPE_ID = '$ctx.args.input.STEP_TYPE_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverMutationupdateSTEPTYPEPARAMMAP": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Mutation",
              "FieldName": "updateSTEP_TYPE_PARAM_MAP",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    #set($updateStatement = \"UPDATE STEP_TYPE_PARAM_MAP SET \")\n    #set($first = true)\n    #foreach($entry in $ctx.args.input.entrySet())\n      #if($entry.key != \"STEP_TYPE_PARAM_MAP_ID\" && $entry.value)\n        #if(!$first)\n          #set($updateStatement = \"$updateStatement, \")\n        #end\n        #set($updateStatement = \"$updateStatement$entry.key = '$entry.value'\")\n        #set($first = false)\n      #end\n    #end\n    #set($updateStatement = \"$updateStatement WHERE STEP_TYPE_PARAM_MAP_ID = '$ctx.args.input.STEP_TYPE_PARAM_MAP_ID'\")\n    \"$updateStatement\"\n  ]\n}",
              "ResponseMappingTemplate": "## Handle RDS Data API response for MySQL (no RETURNING clause)\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n## MySQL INSERT/UPDATE doesn't return data, so return input with success indicator\n$util.toJson($ctx.args.input)",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistCONFIGPARAMS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listCONFIG_PARAMS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM CONFIG_PARAM ORDER BY CONFIG_PARAM_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistFILTERCRITERIAS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listFILTER_CRITERIAS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM FILTER_CRITERIA ORDER BY FILTER_CRITERIA_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistLOANAPPS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listLOAN_APPS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM LOAN_APP ORDER BY LOAN_APP_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistLOANAPPEXECSS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listLOAN_APP_EXECSS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM LOAN_APP_EXECS ORDER BY LOAN_APP_EXECS_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistLOANAPPSTEPSTATUSS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listLOAN_APP_STEP_STATUSS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM LOAN_APP_STEP_STATUS ORDER BY LOAN_APP_STEP_STATUS_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistNEWMEMBERTOKENS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listNEW_MEMBER_TOKENS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM NEW_MEMBER_TOKEN ORDER BY NEW_MEMBER_TOKEN_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistORIGINPRODUCTS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listORIGIN_PRODUCTS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM ORIGIN_PRODUCT ORDER BY ORIGIN_PRODUCT_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistREDIRECTURLS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listREDIRECT_URLS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM REDIRECT_URL ORDER BY REDIRECT_URL_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSERVICES": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSERVICES",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE ORDER BY SERVICE_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSERVICEDOMAINS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSERVICE_DOMAINS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_DOMAIN ORDER BY SERVICE_DOMAIN_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSERVICEEXPRMAPPINGS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSERVICE_EXPR_MAPPINGS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_EXPR_MAPPING ORDER BY SERVICE_EXPR_MAPPING_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSERVICEPARAMS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSERVICE_PARAMS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_PARAM ORDER BY SERVICE_PARAM_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSERVICEPARAMMAPPINGS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSERVICE_PARAM_MAPPINGS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_PARAM_MAPPING ORDER BY SERVICE_PARAM_MAPPING_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSERVICEPROVIDERS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSERVICE_PROVIDERS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SERVICE_PROVIDER ORDER BY SERVICE_PROVIDER_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSORTCRITERIAS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSORT_CRITERIAS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM SORT_CRITERIA ORDER BY SORT_CRITERIA_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSTEPSERVICEMAPPINGS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSTEP_SERVICE_MAPPINGS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM STEP_SERVICE_MAPPING ORDER BY STEP_SERVICE_MAPPING_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSTEPTYPES": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSTEP_TYPES",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM STEP_TYPE ORDER BY STEP_TYPE_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          },
          "GraphQlResolverQuerylistSTEPTYPEPARAMMAPS": {
            "Type": "AWS::AppSync::Resolver",
            "DependsOn": "GraphQlSchema",
            "Properties": {
              "ApiId": {
                "Fn::GetAtt": [
                  "GraphQlApi",
                  "ApiId"
                ]
              },
              "TypeName": "Query",
              "FieldName": "listSTEP_TYPE_PARAM_MAPS",
              "RequestMappingTemplate": "{\n  \"version\": \"2018-05-29\",\n  \"statements\": [\n    \"SELECT * FROM STEP_TYPE_PARAM_MAP ORDER BY STEP_TYPE_PARAM_MAP_ID#if($ctx.args.nextToken) OFFSET $ctx.args.nextToken#end#if($ctx.args.limit) LIMIT $ctx.args.limit#end\"\n  ]\n}",
              "ResponseMappingTemplate": "## Raise a GraphQL field error in case of a datasource invocation error\n#if($ctx.error)\n    $utils.error($ctx.error.message, $ctx.error.type)\n#end\n\n#set($result = $utils.rds.toJsonObject($ctx.result)[0])\n#set($items = $result)\n#set($hasNextToken = false)\n#if($ctx.args.limit && $items.size() == $ctx.args.limit)\n  #set($hasNextToken = true)\n  #set($nextTokenValue = $ctx.args.nextToken)\n  #if(!$nextTokenValue)\n    #set($nextTokenValue = 0)\n  #end\n  #set($nextTokenValue = $nextTokenValue + $ctx.args.limit)\n#end\n{\n  \"items\": $util.toJson($items),\n  #if($hasNextToken)\"nextToken\": \"$nextTokenValue\"#else\"nextToken\": null#end\n}",
              "Kind": "UNIT",
              "DataSourceName": {
                "Fn::GetAtt": [
                  "GraphQlDsStageDataSource",
                  "Name"
                ]
              }
            }
          }
        },
        "Outputs": {
          "ServerlessDeploymentBucketName": {
            "Value": "hazel-mapping-serverless-deployment-bucket",
            "Export": {
              "Name": "sls-vue-appsync-api-dev-ServerlessDeploymentBucketName"
            }
          },
          "GraphQlApiKeyDefault": {
            "Value": {
              "Fn::GetAtt": [
                "GraphQlApiKeyDefault",
                "ApiKey"
              ]
            }
          },
          "GraphQlApiId": {
            "Value": {
              "Fn::GetAtt": [
                "GraphQlApi",
                "ApiId"
              ]
            },
            "Export": {
              "Name": {
                "Fn::Sub": "${AWS::StackName}-GraphQlApiId"
              }
            }
          },
          "GraphQlApiUrl": {
            "Value": {
              "Fn::GetAtt": [
                "GraphQlApi",
                "GraphQLUrl"
              ]
            },
            "Export": {
              "Name": {
                "Fn::Sub": "${AWS::StackName}-GraphQlApiUrl"
              }
            }
          }
        }
      }
    },
    "custom": {
      "userPoolId": "us-east-2_iAtP0Uzh5",
      "databaseConfig": {
        "stages": {
          "dev": {
            "enabled": true,
            "secretArn": "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-a11d98c5-d647-45a2-9978-f81be7aa3d60-iDsvX3",
            "databaseName": "hazel_mapping_dev",
            "clusterIdentifier": "hazel-mapping",
            "minCapacity": 1,
            "maxCapacity": 2
          },
          "test": {
            "enabled": true,
            "secretArn": "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-cb7e7e17-e3eb-4916-a783-a3fad3597623-NOkBYH",
            "databaseName": "hazel_mapping_test",
            "clusterIdentifier": "hazel-mapping-test",
            "minCapacity": 1,
            "maxCapacity": 4
          },
          "uat": {
            "enabled": true,
            "secretArn": "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-5caa7e9f-9f43-4073-ba7f-af959e3cf6bb-yn4rKu",
            "databaseName": "hazel_mapping_uat",
            "clusterIdentifier": "hazel-mapping-uat",
            "minCapacity": 1,
            "maxCapacity": 4
          },
          "live": {
            "enabled": true,
            "secretArn": "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-5975818b-f15c-4381-b0ba-1f281f97610d-GlpEdy",
            "databaseName": "hazel_mapping_live",
            "clusterIdentifier": "hazel-mapping-live",
            "minCapacity": 2,
            "maxCapacity": 8
          }
        }
      },
      "stageConfig": {
        "enabled": true,
        "secretArn": "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-a11d98c5-d647-45a2-9978-f81be7aa3d60-iDsvX3",
        "databaseName": "hazel_mapping_dev",
        "clusterIdentifier": "hazel-mapping",
        "minCapacity": 1,
        "maxCapacity": 2
      },
      "appSync": {
        "name": "vue-appsync-api-dev",
        "authenticationType": "AMAZON_COGNITO_USER_POOLS",
        "userPoolConfig": {
          "userPoolId": "us-east-2_iAtP0Uzh5",
          "defaultAction": "ALLOW"
        },
        "additionalAuthenticationProviders": [
          {
            "authenticationType": "API_KEY",
            "apiKeyConfig": {
              "apiKeyExpirationDays": 30
            }
          }
        ],
        "schema": "schema.graphql",
        "logging": {
          "level": "ALL",
          "roleArn": {
            "Fn::GetAtt": [
              "AppSyncLoggingRole",
              "Arn"
            ]
          }
        },
        "dataSources": [
          {
            "type": "RELATIONAL_DATABASE",
            "name": "StageDataSource",
            "config": {
              "dbClusterIdentifier": "hazel-mapping",
              "databaseName": "hazel_mapping_dev",
              "awsSecretStoreArn": "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-a11d98c5-d647-45a2-9978-f81be7aa3d60-iDsvX3",
              "serviceRoleArn": {
                "$ref": "$[\"service\"][\"provider\"][\"compiledCloudFormationTemplate\"][\"Resources\"][\"GraphQlDsStageDataSource\"][\"Properties\"][\"ServiceRoleArn\"]"
              }
            }
          }
        ],
        "mappingTemplates": [
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createCONFIG_PARAM",
            "request": "Mutation.createCONFIG_PARAM.request.vtl",
            "response": "Mutation.createCONFIG_PARAM.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createFILTER_CRITERIA",
            "request": "Mutation.createFILTER_CRITERIA.request.vtl",
            "response": "Mutation.createFILTER_CRITERIA.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createORIGIN_PRODUCT",
            "request": "Mutation.createORIGIN_PRODUCT.request.vtl",
            "response": "Mutation.createORIGIN_PRODUCT.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createREDIRECT_URL",
            "request": "Mutation.createREDIRECT_URL.request.vtl",
            "response": "Mutation.createREDIRECT_URL.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSERVICE",
            "request": "Mutation.createSERVICE.request.vtl",
            "response": "Mutation.createSERVICE.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSERVICE_DOMAIN",
            "request": "Mutation.createSERVICE_DOMAIN.request.vtl",
            "response": "Mutation.createSERVICE_DOMAIN.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSERVICE_EXPR_MAPPING",
            "request": "Mutation.createSERVICE_EXPR_MAPPING.request.vtl",
            "response": "Mutation.createSERVICE_EXPR_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSERVICE_PARAM",
            "request": "Mutation.createSERVICE_PARAM.request.vtl",
            "response": "Mutation.createSERVICE_PARAM.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSERVICE_PARAM_MAPPING",
            "request": "Mutation.createSERVICE_PARAM_MAPPING.request.vtl",
            "response": "Mutation.createSERVICE_PARAM_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSERVICE_PROVIDER",
            "request": "Mutation.createSERVICE_PROVIDER.request.vtl",
            "response": "Mutation.createSERVICE_PROVIDER.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSORT_CRITERIA",
            "request": "Mutation.createSORT_CRITERIA.request.vtl",
            "response": "Mutation.createSORT_CRITERIA.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSTEP_SERVICE_MAPPING",
            "request": "Mutation.createSTEP_SERVICE_MAPPING.request.vtl",
            "response": "Mutation.createSTEP_SERVICE_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSTEP_TYPE",
            "request": "Mutation.createSTEP_TYPE.request.vtl",
            "response": "Mutation.createSTEP_TYPE.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "createSTEP_TYPE_PARAM_MAP",
            "request": "Mutation.createSTEP_TYPE_PARAM_MAP.request.vtl",
            "response": "Mutation.createSTEP_TYPE_PARAM_MAP.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteCONFIG_PARAM",
            "request": "Mutation.deleteCONFIG_PARAM.request.vtl",
            "response": "Mutation.deleteCONFIG_PARAM.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteFILTER_CRITERIA",
            "request": "Mutation.deleteFILTER_CRITERIA.request.vtl",
            "response": "Mutation.deleteFILTER_CRITERIA.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteORIGIN_PRODUCT",
            "request": "Mutation.deleteORIGIN_PRODUCT.request.vtl",
            "response": "Mutation.deleteORIGIN_PRODUCT.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteREDIRECT_URL",
            "request": "Mutation.deleteREDIRECT_URL.request.vtl",
            "response": "Mutation.deleteREDIRECT_URL.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSERVICE",
            "request": "Mutation.deleteSERVICE.request.vtl",
            "response": "Mutation.deleteSERVICE.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSERVICE_DOMAIN",
            "request": "Mutation.deleteSERVICE_DOMAIN.request.vtl",
            "response": "Mutation.deleteSERVICE_DOMAIN.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSERVICE_EXPR_MAPPING",
            "request": "Mutation.deleteSERVICE_EXPR_MAPPING.request.vtl",
            "response": "Mutation.deleteSERVICE_EXPR_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSERVICE_PARAM",
            "request": "Mutation.deleteSERVICE_PARAM.request.vtl",
            "response": "Mutation.deleteSERVICE_PARAM.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSERVICE_PARAM_MAPPING",
            "request": "Mutation.deleteSERVICE_PARAM_MAPPING.request.vtl",
            "response": "Mutation.deleteSERVICE_PARAM_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSERVICE_PROVIDER",
            "request": "Mutation.deleteSERVICE_PROVIDER.request.vtl",
            "response": "Mutation.deleteSERVICE_PROVIDER.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSORT_CRITERIA",
            "request": "Mutation.deleteSORT_CRITERIA.request.vtl",
            "response": "Mutation.deleteSORT_CRITERIA.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSTEP_SERVICE_MAPPING",
            "request": "Mutation.deleteSTEP_SERVICE_MAPPING.request.vtl",
            "response": "Mutation.deleteSTEP_SERVICE_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSTEP_TYPE",
            "request": "Mutation.deleteSTEP_TYPE.request.vtl",
            "response": "Mutation.deleteSTEP_TYPE.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "deleteSTEP_TYPE_PARAM_MAP",
            "request": "Mutation.deleteSTEP_TYPE_PARAM_MAP.request.vtl",
            "response": "Mutation.deleteSTEP_TYPE_PARAM_MAP.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateCONFIG_PARAM",
            "request": "Mutation.updateCONFIG_PARAM.request.vtl",
            "response": "Mutation.updateCONFIG_PARAM.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateFILTER_CRITERIA",
            "request": "Mutation.updateFILTER_CRITERIA.request.vtl",
            "response": "Mutation.updateFILTER_CRITERIA.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateORIGIN_PRODUCT",
            "request": "Mutation.updateORIGIN_PRODUCT.request.vtl",
            "response": "Mutation.updateORIGIN_PRODUCT.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateREDIRECT_URL",
            "request": "Mutation.updateREDIRECT_URL.request.vtl",
            "response": "Mutation.updateREDIRECT_URL.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSERVICE",
            "request": "Mutation.updateSERVICE.request.vtl",
            "response": "Mutation.updateSERVICE.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSERVICE_DOMAIN",
            "request": "Mutation.updateSERVICE_DOMAIN.request.vtl",
            "response": "Mutation.updateSERVICE_DOMAIN.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSERVICE_EXPR_MAPPING",
            "request": "Mutation.updateSERVICE_EXPR_MAPPING.request.vtl",
            "response": "Mutation.updateSERVICE_EXPR_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSERVICE_PARAM",
            "request": "Mutation.updateSERVICE_PARAM.request.vtl",
            "response": "Mutation.updateSERVICE_PARAM.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSERVICE_PARAM_MAPPING",
            "request": "Mutation.updateSERVICE_PARAM_MAPPING.request.vtl",
            "response": "Mutation.updateSERVICE_PARAM_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSERVICE_PROVIDER",
            "request": "Mutation.updateSERVICE_PROVIDER.request.vtl",
            "response": "Mutation.updateSERVICE_PROVIDER.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSORT_CRITERIA",
            "request": "Mutation.updateSORT_CRITERIA.request.vtl",
            "response": "Mutation.updateSORT_CRITERIA.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSTEP_SERVICE_MAPPING",
            "request": "Mutation.updateSTEP_SERVICE_MAPPING.request.vtl",
            "response": "Mutation.updateSTEP_SERVICE_MAPPING.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSTEP_TYPE",
            "request": "Mutation.updateSTEP_TYPE.request.vtl",
            "response": "Mutation.updateSTEP_TYPE.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Mutation",
            "field": "updateSTEP_TYPE_PARAM_MAP",
            "request": "Mutation.updateSTEP_TYPE_PARAM_MAP.request.vtl",
            "response": "Mutation.updateSTEP_TYPE_PARAM_MAP.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listCONFIG_PARAMS",
            "request": "Query.listCONFIG_PARAMS.request.vtl",
            "response": "Query.listCONFIG_PARAMS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listFILTER_CRITERIAS",
            "request": "Query.listFILTER_CRITERIAS.request.vtl",
            "response": "Query.listFILTER_CRITERIAS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listLOAN_APPS",
            "request": "Query.listLOAN_APPS.request.vtl",
            "response": "Query.listLOAN_APPS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listLOAN_APP_EXECSS",
            "request": "Query.listLOAN_APP_EXECSS.request.vtl",
            "response": "Query.listLOAN_APP_EXECSS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listLOAN_APP_STEP_STATUSS",
            "request": "Query.listLOAN_APP_STEP_STATUSS.request.vtl",
            "response": "Query.listLOAN_APP_STEP_STATUSS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listNEW_MEMBER_TOKENS",
            "request": "Query.listNEW_MEMBER_TOKENS.request.vtl",
            "response": "Query.listNEW_MEMBER_TOKENS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listORIGIN_PRODUCTS",
            "request": "Query.listORIGIN_PRODUCTS.request.vtl",
            "response": "Query.listORIGIN_PRODUCTS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listREDIRECT_URLS",
            "request": "Query.listREDIRECT_URLS.request.vtl",
            "response": "Query.listREDIRECT_URLS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSERVICES",
            "request": "Query.listSERVICES.request.vtl",
            "response": "Query.listSERVICES.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSERVICE_DOMAINS",
            "request": "Query.listSERVICE_DOMAINS.request.vtl",
            "response": "Query.listSERVICE_DOMAINS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSERVICE_EXPR_MAPPINGS",
            "request": "Query.listSERVICE_EXPR_MAPPINGS.request.vtl",
            "response": "Query.listSERVICE_EXPR_MAPPINGS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSERVICE_PARAMS",
            "request": "Query.listSERVICE_PARAMS.request.vtl",
            "response": "Query.listSERVICE_PARAMS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSERVICE_PARAM_MAPPINGS",
            "request": "Query.listSERVICE_PARAM_MAPPINGS.request.vtl",
            "response": "Query.listSERVICE_PARAM_MAPPINGS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSERVICE_PROVIDERS",
            "request": "Query.listSERVICE_PROVIDERS.request.vtl",
            "response": "Query.listSERVICE_PROVIDERS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSORT_CRITERIAS",
            "request": "Query.listSORT_CRITERIAS.request.vtl",
            "response": "Query.listSORT_CRITERIAS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSTEP_SERVICE_MAPPINGS",
            "request": "Query.listSTEP_SERVICE_MAPPINGS.request.vtl",
            "response": "Query.listSTEP_SERVICE_MAPPINGS.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSTEP_TYPES",
            "request": "Query.listSTEP_TYPES.request.vtl",
            "response": "Query.listSTEP_TYPES.response.vtl"
          },
          {
            "dataSource": "StageDataSource",
            "type": "Query",
            "field": "listSTEP_TYPE_PARAM_MAPS",
            "request": "Query.listSTEP_TYPE_PARAM_MAPS.request.vtl",
            "response": "Query.listSTEP_TYPE_PARAM_MAPS.response.vtl"
          }
        ]
      }
    },
    "plugins": [
      "serverless-appsync-plugin"
    ],
    "pluginsData": {},
    "functions": {},
    "resources": {
      "Resources": {
        "EmailDomainValidationFunction": {
          "Type": "AWS::Lambda::Function",
          "Properties": {
            "FunctionName": "email-domain-validation-dev",
            "Runtime": "nodejs18.x",
            "Handler": "index.handler",
            "Code": {
              "ZipFile": "exports.handler = async (event) => {\n  const email = event.request.userAttributes.email;\n  \n  // Input validation\n  if (!email || typeof email !== 'string') {\n    throw new Error('Invalid email format');\n  }\n  \n  var emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    throw new Error('Invalid email format');\n  }\n  \n  if (!email.endsWith('@velera.com')) {\n    throw new Error('Only @velera.com email addresses are allowed');\n  }\n  \n  console.log('Email validation passed for domain: ' + email.split('@')[1]);\n  return event;\n};\n"
            },
            "Role": {
              "Fn::GetAtt": [
                "LambdaExecutionRole",
                "Arn"
              ]
            }
          }
        },
        "PostConfirmationFunction": {
          "Type": "AWS::Lambda::Function",
          "Properties": {
            "FunctionName": "post-confirmation-dev",
            "Runtime": "nodejs18.x",
            "Handler": "index.handler",
            "Code": {
              "ZipFile": "const { CognitoIdentityProviderClient, AdminAddUserToGroupCommand, ListUsersInGroupCommand } = require('@aws-sdk/client-cognito-identity-provider');\nconst { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');\n\nconst cognito = new CognitoIdentityProviderClient({ region: 'us-east-2' });\nconst ses = new SESClient({ region: 'us-east-2' });\n\nexports.handler = async (event) => {\n  const { userPoolId, userName } = event;\n  const userAttributes = event.request.userAttributes;\n  const region = process.env.AWS_REGION;\n  \n  // Input validation\n  if (!userAttributes.email || !userAttributes.email.includes('@')) {\n    console.error('Invalid email format');\n    return event;\n  }\n  \n  try {\n    // Add user to ReadOnly group by default\n    await cognito.send(new AdminAddUserToGroupCommand({\n      GroupName: 'readonly',\n      UserPoolId: userPoolId,\n      Username: userName\n    }));\n    \n    console.log('User ' + userName + ' added to readonly group');\n    \n    // Send notification to admins about new user\n    const adminUsers = await cognito.send(new ListUsersInGroupCommand({\n      GroupName: 'admin',\n      UserPoolId: userPoolId\n    }));\n    \n    const adminEmails = adminUsers.Users.map(user => \n      user.Attributes.find(attr => attr.Name === 'email')?.Value\n    ).filter(email => email && email.includes('@'));\n    \n    console.log('Admin emails found:', JSON.stringify(adminEmails));\n    \n    if (adminEmails.length > 0) {\n      const emailParams = {\n        Source: 'eshubkagel@velera.com',\n        Destination: { ToAddresses: adminEmails },\n        Message: {\n          Subject: { Data: 'New User Registration: ' + userAttributes.email.split('@')[0] + '@*** (' + (userAttributes.name || 'Unknown') + ')' },\n          Body: {\n            Text: {\n              Data: 'New user has registered and been added to readonly group.\\n\\nUser Details:\\n- Email: ' + userAttributes.email + '\\n- Username: ' + userName + '\\n- ' + (userAttributes.name || 'Requested Access: Unknown') + '\\n\\nTo add user to requested group:\\nhttps://us-east-2.console.aws.amazon.com/cognito/v2/idp/user-pools/' + userPoolId + '/user-management/groups/details/' + (userAttributes.name ? userAttributes.name.replace('Requested: ', '').toLowerCase() : 'developer') + '/add-user?region=' + region\n            }\n          }\n        }\n      };\n      \n      console.log('Sending email TO:', JSON.stringify(adminEmails));\n      const result = await ses.send(new SendEmailCommand(emailParams));\n      console.log('SES Response:', JSON.stringify(result));\n      console.log('Notification sent to ' + adminEmails.length + ' admins');\n    }\n  } catch (error) {\n    console.error('Error in post-confirmation:', error.message);\n    console.error('Full error:', JSON.stringify(error));\n  }\n  \n  return event;\n};\n"
            },
            "Role": {
              "Fn::GetAtt": [
                "PostConfirmationLambdaRole",
                "Arn"
              ]
            }
          }
        },
        "PostConfirmationLambdaRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "lambda.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "ManagedPolicyArns": [
              "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
            ],
            "Policies": [
              {
                "PolicyName": "CognitoGroupManagement",
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Action": [
                        "cognito-idp:AdminAddUserToGroup",
                        "cognito-idp:ListUsersInGroup"
                      ],
                      "Resource": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
                    },
                    {
                      "Effect": "Allow",
                      "Action": [
                        "ses:SendEmail"
                      ],
                      "Resource": [
                        "arn:aws:ses:us-east-2:*:identity/eshubkagel@velera.com"
                      ]
                    }
                  ]
                }
              }
            ]
          }
        },
        "PostConfirmationLambdaPermission": {
          "Type": "AWS::Lambda::Permission",
          "Properties": {
            "FunctionName": {
              "Ref": "PostConfirmationFunction"
            },
            "Action": "lambda:InvokeFunction",
            "Principal": "cognito-idp.amazonaws.com",
            "SourceArn": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
          }
        },
        "LambdaExecutionRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "lambda.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "ManagedPolicyArns": [
              "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
            ]
          }
        },
        "CognitoLambdaPermission": {
          "Type": "AWS::Lambda::Permission",
          "Properties": {
            "FunctionName": {
              "Ref": "EmailDomainValidationFunction"
            },
            "Action": "lambda:InvokeFunction",
            "Principal": "cognito-idp.amazonaws.com",
            "SourceArn": "arn:aws:cognito-idp:us-east-2:794611117044:userpool/us-east-2_iAtP0Uzh5"
          }
        },
        "AppSyncLoggingRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "appsync.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "Policies": [
              {
                "PolicyName": "CloudWatchLogsAccess",
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Action": [
                        "logs:CreateLogGroup",
                        "logs:CreateLogStream",
                        "logs:PutLogEvents"
                      ],
                      "Resource": "*"
                    }
                  ]
                }
              }
            ]
          }
        },
        "RDSServiceRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "appsync.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "Policies": [
              {
                "PolicyName": "RDSDataAccess",
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Action": [
                        "rds-data:*"
                      ],
                      "Resource": [
                        "arn:aws:rds:us-east-2:*:cluster:hazel-mapping"
                      ]
                    },
                    {
                      "Effect": "Allow",
                      "Action": [
                        "secretsmanager:GetSecretValue",
                        "kms:Decrypt",
                        "kms:DescribeKey"
                      ],
                      "Resource": [
                        "arn:aws:secretsmanager:us-east-2:794611117044:secret:rds!cluster-a11d98c5-d647-45a2-9978-f81be7aa3d60-iDsvX3",
                        "arn:aws:kms:us-east-2:*:key/*"
                      ]
                    },
                    {
                      "Effect": "Allow",
                      "Action": [
                        "logs:CreateLogGroup",
                        "logs:CreateLogStream",
                        "logs:PutLogEvents"
                      ],
                      "Resource": [
                        "arn:aws:logs:us-east-2:*:log-group:/aws/appsync/*"
                      ]
                    }
                  ]
                }
              }
            ]
          }
        }
      },
      "Outputs": {}
    },
    "configValidationMode": "warn",
    "serviceFilename": "serverless.yml",
    "initialServerlessConfig": {
      "service": "vue-appsync-api",
      "provider": {
        "$ref": "$[\"service\"][\"provider\"]"
      },
      "custom": {
        "$ref": "$[\"service\"][\"custom\"]"
      },
      "plugins": {
        "$ref": "$[\"service\"][\"plugins\"]"
      },
      "resources": {
        "$ref": "$[\"service\"][\"resources\"]"
      }
    },
    "layers": {},
    "isDashboardMonitoringPreconfigured": false
  },
  "package": {
    "artifactDirectoryName": "serverless/vue-appsync-api/dev/1759958724425-2025-10-08T21:25:24.425Z",
    "artifact": ""
  }
}