<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenAPI Service Import Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .upload-section {
            margin-bottom: 20px;
            padding: 20px;
            border: 2px dashed #ccc;
            border-radius: 5px;
        }
        .service-list {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .service-item {
            background-color: white;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            border-left: 4px solid #007bff;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        button {
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>OpenAPI Service Import Demo</h1>
    
    <div class="upload-section">
        <h3>Upload OpenAPI File</h3>
        <input type="file" id="fileInput" accept=".yaml,.yml,.json" />
        <button onclick="parseFile()">Parse OpenAPI File</button>
    </div>
    
    <div id="error" class="error" style="display: none;"></div>
    <div id="success" class="success" style="display: none;"></div>
    
    <div id="services" class="service-list" style="display: none;">
        <h3>Discovered Services</h3>
        <div id="servicesList"></div>
    </div>
    
    <div id="serviceDetails" style="display: none;">
        <h3>Service Details</h3>
        <div id="serviceInfo"></div>
        <h4>Request Parameters</h4>
        <table id="requestParams">
            <thead>
                <tr>
                    <th>Parameter Name</th>
                    <th>Type</th>
                    <th>Required</th>
                    <th>Description</th>
                    <th>Location</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        <h4>Response Parameters</h4>
        <table id="responseParams">
            <thead>
                <tr>
                    <th>Parameter Name</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <script>
        let parsedServices = [];
        let fullApiSpec = null;
        
        // Resolve $ref references
        function resolveRef(ref) {
            if (!fullApiSpec || !ref.startsWith('#/')) return null;
            
            const path = ref.substring(2).split('/');
            let current = fullApiSpec;
            
            for (const segment of path) {
                if (current && typeof current === 'object' && segment in current) {
                    current = current[segment];
                } else {
                    return null;
                }
            }
            
            return current;
        }
        
        // Fallback function to extract basic OpenAPI structure from text
        function extractBasicOpenAPIStructure(content) {
            const api = {
                openapi: '3.0.0',
                info: { title: 'Imported API', version: '1.0.0' },
                paths: {}
            };
            
            // Extract paths using regex patterns
            const pathMatches = content.match(/^\s*\/[^:\s]+:/gm);
            if (pathMatches) {
                pathMatches.forEach(pathMatch => {
                    const path = pathMatch.trim().replace(':', '');
                    api.paths[path] = {};
                    
                    // Look for HTTP methods after this path
                    const pathIndex = content.indexOf(pathMatch);
                    const nextPathIndex = content.indexOf('\n  /', pathIndex + 1);
                    const pathSection = content.substring(pathIndex, nextPathIndex > 0 ? nextPathIndex : content.length);
                    
                    const methodMatches = pathSection.match(/^\s{4}(get|post|put|delete|patch|options|head):/gm);
                    if (methodMatches) {
                        methodMatches.forEach(methodMatch => {
                            const method = methodMatch.trim().replace(':', '');
                            api.paths[path][method] = {
                                summary: `${method.toUpperCase()} ${path}`,
                                operationId: `${method}_${path.replace(/[^a-zA-Z0-9]/g, '_')}`,
                                parameters: [],
                                responses: { '200': { description: 'Success' } }
                            };
                        });
                    }
                });
            }
            
            return api;
        }
        
        // Simple YAML parser for basic OpenAPI files
        function parseYAML(yamlText) {
            // This is a very basic YAML parser - for production use a proper library
            const lines = yamlText.split('\n');
            const result = {};
            let currentPath = [];
            let currentObject = result;
            
            for (const line of lines) {
                if (line.trim() === '' || line.trim().startsWith('#')) continue;
                
                const indent = line.length - line.trimStart().length;
                const trimmed = line.trim();
                
                if (trimmed.includes(':')) {
                    const [key, ...valueParts] = trimmed.split(':');
                    const value = valueParts.join(':').trim();
                    
                    // Adjust current path based on indentation
                    const level = Math.floor(indent / 2);
                    currentPath = currentPath.slice(0, level);
                    
                    // Navigate to correct object
                    currentObject = result;
                    for (const pathPart of currentPath) {
                        currentObject = currentObject[pathPart];
                    }
                    
                    if (value === '' || value === '{}' || value === '[]') {
                        currentObject[key.trim()] = value === '[]' ? [] : {};
                        currentPath.push(key.trim());
                    } else {
                        // Try to parse as number or boolean
                        let parsedValue = value;
                        if (value === 'true') parsedValue = true;
                        else if (value === 'false') parsedValue = false;
                        else if (!isNaN(Number(value)) && value !== '') parsedValue = Number(value);
                        
                        currentObject[key.trim()] = parsedValue;
                    }
                }
            }
            
            return result;
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            document.getElementById('success').style.display = 'none';
        }
        
        function showSuccess(message) {
            const successDiv = document.getElementById('success');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            document.getElementById('error').style.display = 'none';
        }
        
        async function parseFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showError('Please select a file');
                return;
            }
            
            try {
                const fileContent = await file.text();
                let api;
                
                // Parse based on file extension
                if (file.name.endsWith('.json')) {
                    api = JSON.parse(fileContent);
                } else {
                    // For YAML files, use simplified approach
                    try {
                        api = parseYAML(fileContent);
                    } catch (yamlError) {
                        // Fallback: try to extract basic structure manually
                        api = extractBasicOpenAPIStructure(fileContent);
                    }
                }
                
                // Store full spec for $ref resolution
                fullApiSpec = api;
                
                // Validate basic OpenAPI structure
                if (!api.openapi && !api.swagger) {
                    throw new Error('Not a valid OpenAPI/Swagger specification');
                }
                
                if (!api.paths) {
                    throw new Error('No paths found in OpenAPI specification');
                }
                
                // Extract services
                const services = [];
                Object.entries(api.paths).forEach(([path, methods]) => {
                    Object.entries(methods).forEach(([method, operation]) => {
                        if (typeof operation === 'object' && operation !== null) {
                            services.push({
                                path,
                                method: method.toUpperCase(),
                                operationId: operation.operationId || `${method}_${path.replace(/[^a-zA-Z0-9]/g, '_')}`,
                                summary: operation.summary || '',
                                description: operation.description || '',
                                parameters: operation.parameters || [],
                                requestBody: operation.requestBody,
                                responses: operation.responses || {}
                            });
                        }
                    });
                });
                
                if (services.length === 0) {
                    throw new Error('No valid operations found in OpenAPI specification');
                }
                
                parsedServices = services;
                displayServices(services);
                showSuccess(`Successfully parsed ${services.length} services from ${file.name}`);
                
            } catch (error) {
                showError(`Failed to parse OpenAPI file: ${error.message}`);
            }
        }
        
        function displayServices(services) {
            const servicesDiv = document.getElementById('services');
            const servicesList = document.getElementById('servicesList');
            
            servicesList.innerHTML = '';
            services.forEach((service, index) => {
                const serviceDiv = document.createElement('div');
                serviceDiv.className = 'service-item';
                serviceDiv.innerHTML = `
                    <strong>${service.method} ${service.path}</strong><br>
                    <em>${service.summary}</em><br>
                    <button onclick="showServiceDetails(${index})">View Details</button>
                `;
                servicesList.appendChild(serviceDiv);
            });
            
            servicesDiv.style.display = 'block';
        }
        
        function showServiceDetails(index) {
            const service = parsedServices[index];
            const serviceInfo = document.getElementById('serviceInfo');
            
            serviceInfo.innerHTML = `
                <p><strong>Method:</strong> ${service.method}</p>
                <p><strong>Path:</strong> ${service.path}</p>
                <p><strong>Operation ID:</strong> ${service.operationId}</p>
                <p><strong>Summary:</strong> ${service.summary}</p>
                <p><strong>Description:</strong> ${service.description}</p>
            `;
            
            // Extract and display request parameters
            const requestParams = extractRequestParameters(service);
            displayParameters('requestParams', requestParams);
            
            // Extract and display response parameters
            const responseParams = extractResponseParameters(service);
            displayParameters('responseParams', responseParams);
            
            document.getElementById('serviceDetails').style.display = 'block';
        }
        
        function extractRequestParameters(service) {
            const params = [];
            
            // Path parameters
            if (service.parameters) {
                service.parameters.forEach(param => {
                    params.push({
                        name: param.name,
                        type: param.schema?.type || 'string',
                        required: param.required || false,
                        description: param.description || '',
                        location: param.in
                    });
                });
            }
            
            // Request body parameters
            if (service.requestBody?.content?.['application/json']?.schema) {
                const schema = service.requestBody.content['application/json'].schema;
                extractSchemaProperties(schema, params, 'body');
            }
            
            return params;
        }
        
        function extractResponseParameters(service) {
            const params = [];
            
            // Extract from 200 response
            const successResponse = service.responses?.['200'];
            if (successResponse?.content?.['application/json']?.schema) {
                const schema = successResponse.content['application/json'].schema;
                extractSchemaProperties(schema, params, 'response');
            }
            
            return params;
        }
        
        function extractSchemaProperties(schema, params, location, prefix = '', visited = new Set()) {
            if (!schema) return;
            
            // Handle $ref references
            if (schema.$ref) {
                const refKey = `${schema.$ref}_${prefix}`;
                if (visited.has(refKey)) {
                    // Avoid infinite recursion
                    const refName = schema.$ref.split('/').pop() || 'RefObject';
                    params.push({
                        name: prefix || refName,
                        type: 'object',
                        required: false,
                        description: `Reference to ${refName} (circular)`,
                        location
                    });
                    return;
                }
                
                visited.add(refKey);
                const resolvedSchema = resolveRef(schema.$ref);
                if (resolvedSchema) {
                    extractSchemaProperties(resolvedSchema, params, location, prefix, visited);
                } else {
                    const refName = schema.$ref.split('/').pop() || 'RefObject';
                    params.push({
                        name: prefix || refName,
                        type: 'object',
                        required: false,
                        description: `Reference to ${refName}`,
                        location
                    });
                }
                visited.delete(refKey);
                return;
            }
            
            // Handle oneOf, anyOf, allOf
            if (schema.oneOf || schema.anyOf || schema.allOf) {
                const variants = schema.oneOf || schema.anyOf || schema.allOf;
                variants.forEach((variant, index) => {
                    const variantPrefix = prefix ? `${prefix}.variant${index}` : `variant${index}`;
                    extractSchemaProperties(variant, params, location, variantPrefix, visited);
                });
                return;
            }
            
            if (schema.properties) {
                Object.entries(schema.properties).forEach(([name, prop]) => {
                    const fullName = prefix ? `${prefix}.${name}` : name;
                    
                    // Handle nested $ref in properties
                    if (prop.$ref) {
                        const resolvedProp = resolveRef(prop.$ref);
                        if (resolvedProp) {
                            extractSchemaProperties(resolvedProp, params, location, fullName, visited);
                        } else {
                            const refName = prop.$ref.split('/').pop() || 'RefObject';
                            params.push({
                                name: fullName,
                                type: 'object',
                                required: schema.required?.includes(name) || false,
                                description: `Reference to ${refName}`,
                                location
                            });
                        }
                    } else {
                        params.push({
                            name: fullName,
                            type: prop.type || (prop.properties ? 'object' : 'string'),
                            required: schema.required?.includes(name) || false,
                            description: prop.description || '',
                            location
                        });
                        
                        // Recursively handle nested objects
                        if (prop.type === 'object' && prop.properties) {
                            extractSchemaProperties(prop, params, location, fullName, visited);
                        } else if (prop.type === 'array' && prop.items) {
                            if (prop.items.$ref) {
                                const resolvedItems = resolveRef(prop.items.$ref);
                                if (resolvedItems) {
                                    extractSchemaProperties(resolvedItems, params, location, `${fullName}[]`, visited);
                                }
                            } else if (prop.items.properties) {
                                extractSchemaProperties(prop.items, params, location, `${fullName}[]`, visited);
                            }
                        }
                    }
                });
            } else if (schema.type === 'array' && schema.items) {
                // Handle array types
                const itemName = prefix || 'items';
                if (schema.items.$ref) {
                    const resolvedItems = resolveRef(schema.items.$ref);
                    if (resolvedItems) {
                        extractSchemaProperties(resolvedItems, params, location, `${itemName}[]`, visited);
                    }
                } else if (schema.items.properties) {
                    extractSchemaProperties(schema.items, params, location, `${itemName}[]`, visited);
                } else {
                    params.push({
                        name: itemName,
                        type: `array<${schema.items.type || 'object'}>`,
                        required: false,
                        description: schema.description || 'Array of items',
                        location
                    });
                }
            }
        }
        
        function displayParameters(tableId, params) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            
            tbody.innerHTML = '';
            params.forEach(param => {
                const row = document.createElement('tr');
                if (tableId === 'requestParams') {
                    row.innerHTML = `
                        <td>${param.name}</td>
                        <td>${param.type}</td>
                        <td>${param.required ? 'Yes' : 'No'}</td>
                        <td>${param.description}</td>
                        <td>${param.location}</td>
                    `;
                } else {
                    row.innerHTML = `
                        <td>${param.name}</td>
                        <td>${param.type}</td>
                        <td>${param.description}</td>
                    `;
                }
                tbody.appendChild(row);
            });
        }
    </script>
</body>
</html>