<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>$ref Resolution Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        pre { background-color: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>$ref Resolution Test</h1>
    <div id="results"></div>

    <script>
        let fullApiSpec = null;
        
        // Resolve $ref references
        function resolveRef(ref) {
            if (!fullApiSpec || !ref.startsWith('#/')) return null;
            
            const path = ref.substring(2).split('/');
            let current = fullApiSpec;
            
            for (const segment of path) {
                if (current && typeof current === 'object' && segment in current) {
                    current = current[segment];
                } else {
                    return null;
                }
            }
            
            return current;
        }
        
        // Extract schema properties with $ref resolution
        function extractSchemaProperties(schema, params, location, prefix = '', visited = new Set()) {
            if (!schema) return;
            
            // Handle $ref references
            if (schema.$ref) {
                const refKey = `${schema.$ref}_${prefix}`;
                if (visited.has(refKey)) {
                    const refName = schema.$ref.split('/').pop() || 'RefObject';
                    params.push({
                        name: prefix || refName,
                        type: 'object',
                        required: false,
                        description: `Reference to ${refName} (circular)`,
                        location
                    });
                    return;
                }
                
                visited.add(refKey);
                const resolvedSchema = resolveRef(schema.$ref);
                if (resolvedSchema) {
                    extractSchemaProperties(resolvedSchema, params, location, prefix, visited);
                } else {
                    const refName = schema.$ref.split('/').pop() || 'RefObject';
                    params.push({
                        name: prefix || refName,
                        type: 'object',
                        required: false,
                        description: `Reference to ${refName} (unresolved)`,
                        location
                    });
                }
                visited.delete(refKey);
                return;
            }
            
            if (schema.properties) {
                Object.entries(schema.properties).forEach(([name, prop]) => {
                    const fullName = prefix ? `${prefix}.${name}` : name;
                    
                    if (prop.$ref) {
                        const resolvedProp = resolveRef(prop.$ref);
                        if (resolvedProp) {
                            extractSchemaProperties(resolvedProp, params, location, fullName, visited);
                        } else {
                            const refName = prop.$ref.split('/').pop() || 'RefObject';
                            params.push({
                                name: fullName,
                                type: 'object',
                                required: schema.required?.includes(name) || false,
                                description: `Reference to ${refName}`,
                                location
                            });
                        }
                    } else {
                        params.push({
                            name: fullName,
                            type: prop.type || (prop.properties ? 'object' : 'string'),
                            required: schema.required?.includes(name) || false,
                            description: prop.description || '',
                            location
                        });
                        
                        if (prop.type === 'object' && prop.properties) {
                            extractSchemaProperties(prop, params, location, fullName, visited);
                        } else if (prop.type === 'array' && prop.items) {
                            if (prop.items.$ref) {
                                const resolvedItems = resolveRef(prop.items.$ref);
                                if (resolvedItems) {
                                    extractSchemaProperties(resolvedItems, params, location, `${fullName}[]`, visited);
                                }
                            } else if (prop.items.properties) {
                                extractSchemaProperties(prop.items, params, location, `${fullName}[]`, visited);
                            }
                        }
                    }
                });
            }
        }
        
        // Simple YAML parser
        function parseYAML(yamlText) {
            const lines = yamlText.split('\n');
            const result = {};
            let currentPath = [];
            let currentObject = result;
            
            for (const line of lines) {
                if (line.trim() === '' || line.trim().startsWith('#')) continue;
                
                const indent = line.length - line.trimStart().length;
                const trimmed = line.trim();
                
                if (trimmed.includes(':')) {
                    const [key, ...valueParts] = trimmed.split(':');
                    const value = valueParts.join(':').trim();
                    
                    const level = Math.floor(indent / 2);
                    currentPath = currentPath.slice(0, level);
                    
                    currentObject = result;
                    for (const pathPart of currentPath) {
                        currentObject = currentObject[pathPart];
                    }
                    
                    if (value === '' || value === '{}' || value === '[]') {
                        currentObject[key.trim()] = value === '[]' ? [] : {};
                        currentPath.push(key.trim());
                    } else {
                        let parsedValue = value;
                        if (value === 'true') parsedValue = true;
                        else if (value === 'false') parsedValue = false;
                        else if (!isNaN(Number(value)) && value !== '') parsedValue = Number(value);
                        
                        currentObject[key.trim()] = parsedValue;
                    }
                }
            }
            
            return result;
        }
        
        // Test with sample OpenAPI spec
        async function runTest() {
            const resultsDiv = document.getElementById('results');
            
            try {
                // Load the Deposit.yaml file content (simplified for demo)
                const sampleSpec = {
                    openapi: '3.0.0',
                    paths: {
                        '/deposit-create': {
                            post: {
                                requestBody: {
                                    content: {
                                        'application/json': {
                                            schema: { $ref: '#/components/schemas/DepositCreateRq' }
                                        }
                                    }
                                },
                                responses: {
                                    '200': {
                                        content: {
                                            'application/json': {
                                                schema: { $ref: '#/components/schemas/DepositCreateRs' }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    components: {
                        schemas: {
                            DepositCreateRq: {
                                type: 'object',
                                properties: {
                                    assetID: { type: 'string', description: 'Asset identifier' },
                                    content: { $ref: '#/components/schemas/DepositContent' }
                                }
                            },
                            DepositCreateRs: {
                                type: 'object',
                                properties: {
                                    statusCode: { type: 'number' },
                                    statusMessage: { type: 'string' },
                                    content: { $ref: '#/components/schemas/DepositResponse' }
                                }
                            },
                            DepositContent: {
                                type: 'object',
                                properties: {
                                    accountType: { type: 'string', enum: ['Checking', 'Savings'] },
                                    customerInfo: { $ref: '#/components/schemas/CustomerInfo' },\n                                    accountDetails: {\n                                        type: 'array',\n                                        items: { $ref: '#/components/schemas/AccountDetail' }\n                                    }\n                                }\n                            },\n                            CustomerInfo: {\n                                type: 'object',\n                                properties: {\n                                    firstName: { type: 'string', description: 'Customer first name' },\n                                    lastName: { type: 'string', description: 'Customer last name' },\n                                    email: { type: 'string', description: 'Customer email' },\n                                    address: { $ref: '#/components/schemas/Address' }\n                                }\n                            },\n                            Address: {\n                                type: 'object',\n                                properties: {\n                                    street: { type: 'string' },\n                                    city: { type: 'string' },\n                                    state: { type: 'string' },\n                                    zipCode: { type: 'string' }\n                                }\n                            },\n                            AccountDetail: {\n                                type: 'object',\n                                properties: {\n                                    accountNumber: { type: 'string' },\n                                    balance: { type: 'number' },\n                                    status: { type: 'string' }\n                                }\n                            },\n                            DepositResponse: {\n                                type: 'object',\n                                properties: {\n                                    accountNumber: { type: 'string' },\n                                    confirmationCode: { type: 'string' }\n                                }\n                            }\n                        }\n                    }\n                };\n                \n                fullApiSpec = sampleSpec;\n                \n                resultsDiv.innerHTML += '<div class=\"test-result success\">✓ OpenAPI spec loaded successfully</div>';\n                \n                // Test $ref resolution\n                const depositCreateRq = resolveRef('#/components/schemas/DepositCreateRq');\n                if (depositCreateRq) {\n                    resultsDiv.innerHTML += '<div class=\"test-result success\">✓ $ref resolution working</div>';\n                } else {\n                    resultsDiv.innerHTML += '<div class=\"test-result error\">✗ $ref resolution failed</div>';\n                    return;\n                }\n                \n                // Extract parameters from the POST /deposit-create endpoint\n                const operation = sampleSpec.paths['/deposit-create'].post;\n                const requestParams = [];\n                const responseParams = [];\n                \n                // Extract request parameters\n                if (operation.requestBody?.content?.['application/json']?.schema) {\n                    const schema = operation.requestBody.content['application/json'].schema;\n                    extractSchemaProperties(schema, requestParams, 'body');\n                }\n                \n                // Extract response parameters\n                if (operation.responses?.['200']?.content?.['application/json']?.schema) {\n                    const schema = operation.responses['200'].content['application/json'].schema;\n                    extractSchemaProperties(schema, responseParams, 'response');\n                }\n                \n                resultsDiv.innerHTML += `<div class=\"test-result info\">Found ${requestParams.length} request parameters and ${responseParams.length} response parameters</div>`;\n                \n                // Display request parameters\n                resultsDiv.innerHTML += '<h3>Request Parameters</h3>';\n                const requestTable = '<table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>' +\n                    requestParams.map(p => `<tr><td>${p.name}</td><td>${p.type}</td><td>${p.required ? 'Yes' : 'No'}</td><td>${p.description}</td></tr>`).join('') +\n                    '</tbody></table>';\n                resultsDiv.innerHTML += requestTable;\n                \n                // Display response parameters\n                resultsDiv.innerHTML += '<h3>Response Parameters</h3>';\n                const responseTable = '<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>' +\n                    responseParams.map(p => `<tr><td>${p.name}</td><td>${p.type}</td><td>${p.description}</td></tr>`).join('') +\n                    '</tbody></table>';\n                resultsDiv.innerHTML += responseTable;\n                \n                // Test circular reference handling\n                resultsDiv.innerHTML += '<div class=\"test-result success\">✓ All tests completed successfully</div>';\n                \n            } catch (error) {\n                resultsDiv.innerHTML += `<div class=\"test-result error\">✗ Test failed: ${error.message}</div>`;\n            }\n        }\n        \n        // Run test on page load\n        window.onload = runTest;\n    </script>\n</body>\n</html>